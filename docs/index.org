#+TITLE: Simple Domain Modeling Language
#+AUTHOR: Simon Johnston
#+EMAIL: johnstonskj@gmail.com
#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty
# #+INFOJS_OPT: view:t toc:t ltoc:t mouse:underline buttons:0 path:http://thomasf.github.io/solarized-css/org-info.min.js
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <style>img { max-width: 800px; height: auto; }</style>
#+HTML_HEAD: <style>div.figure { text-align: center; }</style>
#+OPTIONS: toc:3

#+BEGIN_SRC emacs-lisp :exports none
(require 'ob-dot) ;; builtin
(require 'ob-bnf)
(require 'ob-sdml)
#+END_SRC


* Introduction

The Simple Domain Modeling Language is a small data-oriented language for constructing, documenting, and reasoning about
a conceptual domain model. For a background on domain modeling see appendix [[app:domain-modeling]]. At it's core SDML
comprises an /abstract model/ whose structure and semantics are described by an [[https://www.w3.org/OWL/][OWL]]
([[https://www.w3.org/RDF/][RDF]]) ontology, and a /surface syntax/ for editing and sharing concrete models. This document
covers both the OWL and SDML representations and the correspondence between them, however the primary focus of the
documentation is the surface syntax as most users will be interacting with it alone. Figure [[fig:model-overview]] shows
the relationship between these high-level components.

#+NAME: fig:model-overview
#+BEGIN_SRC dot :file sdml-overview.png :exports results
digraph G {
  bgcolor="transparent";
  rankdir="LR";
  node [fontsize=10];
  edge [fontsize=9; fontcolor=darkgrey];
  
  abstract [shape=ellipse; label="Abstract\nModel"];

  rdf [shape=ellipse; label="RDF/OWL"];
  sdml [shape=ellipse; label="Surface\nSyntax"];  
  abstract -> rdf [label="semantics"];  
  abstract -> sdml [label="syntax"];

  concrete [shape=ellipse; style=dotted; label="Concrete\nModel"];
  rdf -> concrete [arrowtail=open; dir=back; style=dotted; label="conforms-to"];
  sdml -> concrete [arrowtail=open; dir=back; style=dotted; label="expressed-in"];
}
#+END_SRC

The language uses some ideas from [[http://www.uml.org/][UML]] which is often used in the construction of such models
today. However, the goal is to keep the language as small as possible, taking away some options where they don't make
sense or where their use may distract from the major purpose of the model. The model also takes some of the language
from Domain-Driven Design[fn:1], namely the separation of entities (/an object defined not by its attributes, but its
identity/) from value objects (/an immutable object that contains attributes but has no conceptual identity/), simply
termed structures in SDML. This model does not include the following as first-class concepts: /aggregates/, /repositories/,
/factories/, or /services/.

#+CAPTION: Model Overview
#+RESULTS: fig:model-overview
[[file:sdml-overview.png]]

One element that is not included in figure [[fig:model-overview]], as it is primarily an implementation decision, is
that the reference implementation for SDML is provided as a [[https://tree-sitter.github.io/tree-sitter/][Tree-Sitter]]
package. While generated tree-sitter parsers are not intended to be fast, or to be part of a compilation processes they
do provide a multitude of language bindings, and a concrete syntax tree allowing easy development of the relatively
simple tools required for SDML usage.

Figure [[fig:model-transforms]] demonstrates another key element of a /Model-Driven Development/[fn:2] style, the transformation
between models and between models and other development artifacts.

#+NAME: fig:model-transforms
#+BEGIN_SRC dot :file sdml-transforms.png :exports results
digraph G {
  bgcolor="transparent";
  rankdir="LR";
  node [fontsize=10];
  edge [fontsize=9; fontcolor=darkgrey];

  abstract [shape=ellipse; label="Abstract\nModel"];

  transform [shape=ellipse; label="Transformation"];
  transform -> abstract [label="source"];

  tsq [shape=ellipse; label="Tree-Sitter\nQueries"];
  transform -> tsq [label="using"];

  other [shape=ellipse; label="Artifact\nModel"];
  transform -> other [label="target"];
}
#+END_SRC

#+CAPTION: Model Transformations
#+RESULTS: fig:model-transforms
[[file:sdml-overview.png]]

# ----- Footnotes

[fn:1] [[https://en.wikipedia.org/wiki/Domain-driven_design][Domain-Driven Design]], Wikipedia
[fn:2] [[https://en.wikipedia.org/wiki/Model-driven_engineering][Model-Driven Development]], Wikipedia


* Surface Syntax

This section describes the SDML surface syntax, a syntax intended to look and feel like a programming language but with
extensibility provided by it's underlying RDF and OWL foundation. The goal of the following syntax is to allow for rapid
capture of domain information but allowing elaboration of details over time. To this end we have made language features
optional wherever possible such that the minimum information neccessary beis required to build a valid model. This
document will use the terms /valid/ to denote a model that has no syntactic errors and /complete/ to denote a valid model
that has no short-form, or /incomplete/, model elements.

** Whitespace and Comments

This grammar chooses to use the JavaScript regular expression character class =\s= which includes the following values,
including all Unicode whitespace.

=/[\f\n\r\t\v\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/=

Comments follow Lisp-like forms, starting with a semi-colon character and continuing to the end of line. Lisp
conventions for single, double, and triple comment characters are useful but in no way enforced.

#+NAME: lst:sdml-ex-comments
#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
; comments start with ';' and go to end of line
#+END_SRC

** Identifiers

An identifier is a string of characters corresponding to the
[[https://unicode.org/reports/tr44/#GC_Values_Table][Unicode General Category]] *Lu* (an uppercase letter) or *Ll* (a
lowercase letter) or the Unicode Low Line (underscore, "_", =U+005F=) character. Specifically an identifer *must* start with
and *must* end with a letter such that the low line character may only appear /within/ the identifier. The following is a
brief BNF description of the identifier syntax.

#+BEGIN_SRC bnf
<identifier>   ::= <word>   | <identifier> _ <word>

<word>         ::= <letter> | <word> <letter>

<letter>       ::= UNICODE_LETTER_UPPER | UNICODE_LETTER_LOWER
#+END_SRC
    
Naming Conventions:

- *Module Name* :: lower Camel Case; i.e. =xsd=, =skos=, =bank=, or =customer=. In general this should be a broad noun.
- *Structure/Entity/Event/Enum Name* :: Upper Camel Case; i.e. =Customer=, =Account=, =Address=, or =Name=. In general
  these are nouns related to, and often narrower than, the module name.
- *Data Type Name* :: Upper Camel Case; i.e. =ShortString=, =AccountNumber=, or =SocialSecurityNumber=. In general these are
  broad nouns, with either a property noun suffix as in =AccountNumber= or a qualifier noun prefix as in =ShortString=. Do
  not create capitalized acronym (SSN) or abbreviation (ID) forms unless these are universally understood within the
  domain.
- *Type Member Name* :: lower Camel Case; i.e. =street=, =accountName=, or =currentValue=. As in data type definitions these are
  broad nouns, with either a property noun suffix as in =accountNumber= or a qualifier noun prefix as in =shortName=. These
  are commonly simply the lower Camel Case version of the corresponding type name.
- *Enum Variant Name* :: Upper Camel Case is the preferred, although SHOUTY CASE is acceptable.

*** Qualified Identifier

A qualified identifier comprises a module identifier followed by the Colon (":", =U+003A=) character and the identifier of a
member within that module.

#+BEGIN_SRC bnf
<qualident>   ::= <identifier> : <identifier>
#+END_SRC

A type reference may be to a locally defined type by an identifier, or an imported type by a qualified identifier.

#+BEGIN_SRC bnf
<identref>   ::= <identifier> | <qualident>
#+END_SRC

** <<sec:modules-and-imports>> Module Declaration and Imports

A module is the container for a set of type definitions and typically models a /Domain/ or /Sub-domain/. A single resource
(in the web sense of some /thing/ identified by an IRI) may contain only a single module. Therefore, the smallest valid
resource is one with an empty model.

An empty module (listing [[lst:sdml-ex-empty-module]]), specifically a module with an empty /body/ which is the content
between the keywords *=is=* and *=end=*.

#+NAME: lst:sdml-ex-empty-module
#+CAPTION: Empty Module
#+BEGIN_SRC sdml :exports code :noeval
module example is end
#+END_SRC

The module in listing [[lst:sdml-ex-import-module]] contains a single import statement /referencing/ the module named =xsd=
making it's members /visible/ in the qualified form =xsd:*=.

#+NAME: lst:sdml-ex-import-module
#+CAPTION: Importing Module
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xsd
end
#+END_SRC

The module in listing [[lst:sdml-ex-import-member]] contains a single import statement /referencing/ the member named =integer= from
the module =xsd= making it visible.

#+NAME: lst:sdml-ex-import-member
#+CAPTION: Importing Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xsd:integer
end
#+END_SRC

To reduce the number of import statements a list of identifiers, both module and member, may be /referenced/ as a list.
Listing [[lst:sdml-ex-import-list]] makes the members =author= and =title= from the module =dc= visible. Lists in SDML start
with the Left Square Bracket ("[", =U+005B=) character and end with the Right Square Bracket ("]", =U+005D=) character with
no separator character between members of the list.

#+NAME: lst:sdml-ex-import-list
#+CAPTION: Importing a List
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import [ dc:title dc:author ]
end
#+END_SRC

** Data Types and Values

The core data types supported by SDML are Boolean, Integer, Decimal, Double, String, (Language-Tagged String), and IRI
References. Values corresponding to these types are termed /simple values/.

*** Simple Values

A Boolean value in SDML is either the keyword ~true~ or ~false~.

An Integer value in SDML is a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however
=00= and =01= are not. The Integer type corresponds to a 64-bit signed integer number.

A Decimal value in SDML is an integer-like value, followed by the Full Stop (".", =U+002E=) character and another
integer-like value. The Decimal type corresponds to a 128-bit representation of a fixed-precision decimal number.

A Double value in SDML is a decimal-like value followed by a lower or upper case letter E (Latin Small Letter E, "e",
=U+0065= or Latin Capital Letter E, "E", =U+0045=), a sign character (Hyphen Minus, "-", =U+002D= or Plus Sign, "+", =U+002B=)
and an integer-like value. The Double type is a 64-bit floating point number (specifically, the "binary64" type defined
in IEEE 754-2008).

A String value in SDML is a sequence of Unicode characters starting and ending with a Quotation Mark ('"', =U+0022=) character. While
standard escape sequences allow for embedding non-printing characters. The form =\u{XXXX}=, where =X= is a single hex digit,
allows for the inclusion of any Unicode characters by their code point. Note that this form requires a minimum of 2 and
a maximum of 6 such digits. In addition,the following single-character escape characters are supported.

#+NAME: tbl:string-escape-characters
#+CAPTION: String Escape Characters
| Escape Character | Character Name (Common Name)          | Unicode Equivalent |
|------------------+---------------------------------------+--------------------|
| =\\=               | Reverse Solidus (Backslash)           | =\u{005C}=           |
| =\/=               | Solidus (Forward Slash)               | =\u{002F}=           |
| =\"=               | Quotation Mark                        | =\u{0022}=           |
| =\a=               | Bell                                  | =\u{0007}=           |
| =\b=               | Backspace                             | =\u{0008}=           |
| =\e=               | Escape                                | =\u{001B}=           |
| =\f=               | Form Feed (Page Break)                | =\u{000C}=           |
| =\n=               | Line Feed (New Line)                  | =\u{000A}=           |
| =\r=               | Carriage Return                       | =\u{000D}=           |
| =\t=               | Character Tabulation (Horizontal Tab) | =\u{0009}=           |
| =\v=               | Line Tabulation (Vertical Tab)        | =\u{000B}=           |

A Language-Tagged String value in SDML is a String as above but immediately followed by a Commercial At ("@", =U+0040=)
character and an unquoted string of characters that conform to a language identifier. Note that both components of such
a string contribute to equality tests, so that ="abc"@en= is not equal to ="abc"@fr=.

An IRI Reference value in SDML is a value IRI value, either absolute or relative, between a Less-Than Sign ("<", =U+003C=)
character and a Greater-Than Sign (">", =U+003E=) character. IRI references are more permissive in the SDML grammar than
the Turtle[fn:3] language.

See section [[sec:mapping-values]] for a more detailed description of values, literals, and data types.

*** Value Constructors

While the value =101= is defined to be an Integer literal, in the presence of sub-types how do you specify the type of a
literal? To accomplish this a /value constructor/ allows for specifying the precise type, or casting a value to a specific
type. The syntax appears as a function call with a type reference followed by a valid /simple value/ surrounded by the
Left Parenthesis ("(", =U+0028=) and Right Parenthesis (")", =U+0029=) characters. The literal value MUST be valid for the
referenced type, or one of it's super-types.

#+NAME: lst:sdml-ex-type-constructor
#+CAPTION: Value Constructor Example
#+BEGIN_SRC sdml :exports code :noeval
xsd:unsigned(1)
#+END_SRC

*** Value Lists

As stated in section [[sec:modules-and-imports]], lists in SDML start with the Left Square Bracket ("[", =U+005B=)
character and end with the Right Square Bracket ("]", =U+005D=) character with no separator character between members of
the list. Value lists are, as one might expect, lists of values and specifically of simple values. Value lists are also
heterogeneous and may contain elements of different types.

#+NAME: lst:sdml-ex-value-lists
#+CAPTION: Value List Example
#+BEGIN_SRC sdml :exports code :noeval
[ "yes" "no" "maybe" ]
#+END_SRC

*** Defining Data Types

A datatype definition introduces a new data type by /restriction/ of some existing base type. Listing
[[lst:sdml-ex-datatype]] shows the /type restriction/ operator, =<-=, defining a new type named ~name~ as a restriction on the
existing XML Schema data type ~xsd:string~.

#+NAME: lst:sdml-ex-datatype
#+CAPTION: New Datatype
#+BEGIN_SRC sdml :exports code :noeval
datatype Name <- xsd:string
#+END_SRC

While such a type is useful for conveying semantic meaning with types it doesn't provide any actual restriction on the
value space of the type. This is accomplished by using a subset of the /facets/ described in XML Schema part 2 to specify
constraints on the new type. For example, in listing [[lst:sdml-ex-restricted-datatype]] we now see that the Name type
is a string whose length is between 5 and 25 characters only.

#+NAME: lst:sdml-ex-restricted-datatype
#+CAPTION: New Datatype with Restrictions
#+BEGIN_SRC sdml :exports code :noeval
datatype Name <- xsd:string is
  @xsd:minLength = 5
  @xsd:maxLength = 25
end
#+END_SRC

From [[https://www.w3.org/2007/OWL/wiki/Quick_Reference_Guide][OWL 2 Web Ontology Language Quick Reference Guide (Second Edition)]]:

#+NAME: tbl:owl-facets
#+CAPTION: OWL Built-in Datatype Facets
| Facet                                                                  | Value                                      | Applicable Datatypes       | Explanation                                                                                |
|------------------------------------------------------------------------+--------------------------------------------+----------------------------+--------------------------------------------------------------------------------------------|
| =xsd:minInclusive=, =xsd:maxInclusive=, =xsd:minExclusive=, =xsd:maxExclusive= | literal in the corresponding datatype      | Numbers, Time Instants     | Restricts the value-space to greater than (equal to) or lesser than (equal to) a value     |
| =xsd:minLength=, =xsd:maxLength=, =xsd:length=                               | Non-negative integer                       | Strings, Binary Data, IRIs | Restricts the value-space based on the lengths of the literals                             |
| =xsd:pattern=                                                            | =xsd:string= literal as a regular expression | Strings, IRIs              | Restricts the value space to literals that match the regular expression                    |
| =rdf:langRange=                                                          | =xsd:string= literal as a regular expression | =rdf:PlainLiteral=           | Restricts the value space to literals with language tags that match the regular expression |

** Annotations

#+NAME: lst:sdml-ex-annotation-property
#+CAPTION: Annotation Property
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xml

  @xml:base = <https://github.com/johnstonskj/tree-sitter-sdml/blob/main/docs/sdml.org>
end
#+END_SRC

#+NAME: lst:sdml-ex-annotation-property-list
#+CAPTION: Annotation Property List
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import skos

  @skos:prefLabel = [
    "example"@en
    "exemple"@fr
    "例子"@zh-CH
  ]
end
#+END_SRC

#+NAME: lst:sdml-ex-annotated-module
#+CAPTION: Annotated Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ xml skos ]

  @xml:base = <https://github.com/johnstonskj/tree-sitter-sdml/blob/main/docs/sdml.org>

  @skos:prefLabel = "Example Module"@en

end
#+END_SRC

From [[https://www.w3.org/TR/owl-ref/#AnnotationProperty-def][OWL Web Ontology Language Reference]], Appendix E: Rules of Thumb for OWL DL ontologies:

#+BEGIN_QUOTE
If a property =a= is used where an annotation property is expected then it should either be one of the built in
annotation properties (=owl:versionInfo=, =rdfs:label=, =rdfs:comment=, =rdfs:seeAlso=, and =rdfs:isDefinedBy=) or there
should be a triple:

=a rdf:type owl:AnnotationProperty=
#+END_QUOTE

** Structured Types

Structured types are those which have a set of /members/ that define their type. Types have identity but also a value
space which is a product of the value space of each member. Each member has a name, a type reference and cardinality
specifiers where appropriate.

*** Members

Structured type members fall into the following categories.

- Identity :: A particular kind of member only available on entities, and required by them, to name the identifier for
  that entity type.
- By-Value :: A reference to a value type, i.e. Enumeration, Event, or Structure. Such a member may indicate the
  cardinality of the target.
- By-Reference :: A reference to an Entity type. Such a member may indicate the cardinality of both the source and the
  target.
- Variants :: A member within an enumeration that specifies a numeric value for each member rather than a type.

For identity, by-value, and by-reference members the general syntax uses the /type reference/ operator, /name/ ~->~ /type/, with
additional keywords and cardinality included as follows.

#+NAME: tbl:member-summary
#+CAPTION: Summary of Member Formats
| Kind         | Keyword  | From-Cardinality | To-Cardinality | Target Types                     |
|--------------+----------+------------------+----------------+----------------------------------|
| Identity     | ~identity~ | No               | No             | Enumeration, Event, or Structure |
| By-Value     |          | No               | Yes            | Enumeration, Event, or Structure |
| By-Reference | ~ref~      | Yes              | Yes            | Entity                           |

Additionally, to allow for the capture of member names before the elaboration of all types the language allows for the
target type to be replaced with the keyword ~unknown~. This marks the member, and by extension it's owning type, as
/incomplete/.

*** Entities

#+NAME: lst:sdml-ex-empty-entity
#+CAPTION: Empty Entity
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person
end
#+END_SRC

The entity ~Person~ is /valid/ but /incomplete/.

#+NAME: lst:sdml-ex-entity-identifying-member
#+CAPTION: Entity with Identifying Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    identity id -> PersonId
  end
end
#+END_SRC

#+NAME: lst:sdml-ex-entity-ref-member
#+CAPTION: Entity with Reference Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    ref contact {0..} -> {0..2} Person is
      @dc:description = "Emergency contact person"
    end
  end
end
#+END_SRC

*** Enums

#+NAME: lst:sdml-ex-empty-enum
#+CAPTION: Empty Enum
#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit
end
#+END_SRC

The enumeration ~DistanceUnit~ is valid but incomplete.

#+NAME: lst:sdml-ex-enum
#+CAPTION: Enum With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit is
    Meter = 1
    Foot = 2
  end
end
#+END_SRC

*** Events

#+NAME: lst:sdml-ex-empty-event
#+CAPTION: Empty Event
#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person
end
#+END_SRC

The event ~PersonNameChanged~ is valid but incomplete.

#+NAME: lst:sdml-ex-event
#+CAPTION: Event
#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person is
    ;; identifier members will be copied from Person 
    fromValue -> Name
    toValue -> Name
  end
end
#+END_SRC

*** Structures

#+NAME: lst:sdml-ex-empty-structure
#+CAPTION: Empty Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length
end
#+END_SRC

The structure ~Length~ is valid but incomplete.

#+NAME: lst:sdml-ex-annotated-structure
#+CAPTION: Annotated Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en
  end
end
#+END_SRC

#+NAME: lst:sdml-ex-structure-members
#+CAPTION: Structure Members
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en

    value -> Decimal
    unit -> DistanceUnit
  end
end
#+END_SRC

#+NAME: lst:sdml-ex-structure-groups
#+CAPTION: Structure MembersGroups
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Account is
    @skos:prefLabel = "Customer Account"@en

    group
      @skos:prefLabel = "Metadata"
      created -> xsd:dateTime
    end

    group
      @skos:prefLabel = "Customer Information"
      ref customer -> {1..1} Customer
    end
  end

end
#+END_SRC

# ----- Footnotes

[fn:3] [[https://www.w3.org/TR/turtle/#sec-iri-references][RDF 1.1 Turtle]], 6.3 IRI References


* RDF Abstract Model

Why RDF? ...

Figure [[fig:owl-ontology]] is an overview of the OWL Ontology, 

#+NAME: fig:owl-ontology
#+BEGIN_SRC dot :file owl-ontology.png :exports results
digraph G {
  bgcolor="transparent";
  rankdir="LR";
  node [fontsize=10];
  edge [fontsize=9; fontcolor=darkgrey];

  Module [shape=ellipse;penwidth=2.0;color=blue;labelcolor=blue];
  Cardinality [shape=ellipse];
  Classifier [shape=ellipse];
  Entity [shape=ellipse];
  Enumeration [shape=ellipse];
  Event [shape=ellipse];
  Group [shape=ellipse];
  Member [shape=ellipse];
  Structure [shape=ellipse];
  Variant [shape=ellipse];
  Datatype [shape=ellipse;label="rdfs:Datatype"];

  Module -> Classifier [label="hasDefinition";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];

  Structure -> Classifier [label="rdfs:subClassOf";arrowhead=empty];
  Entity -> Structure [label="rdfs:subClassOf";arrowhead=empty];
  Enumeration -> Classifier [label="rdfs:subClassOf";arrowhead=empty];
  Event -> Structure [label="rdfs:subClassOf";arrowhead=empty];
  Datatype -> Classifier [label="rdfs:subClassOf";arrowhead=empty];

  Event -> Entity [label="eventSource";dir=both;arrowtail=odiamond;arrowhead=open];

  Datatype -> Datatype [label="baseDatatype";dir=both;arrowtail=odiamond;arrowhead=open];

  Structure -> Group [label="hasGroup";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];
  Structure -> Member [label="hasMember";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];
  Entity -> Member [label="hasIdentifier";dir=both;arrowtail=diamond;arrowhead=open;headlabel="1"];

  Group -> Member [label="hasMember";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];

  Enumeration -> Variant [label="hasVariant";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];

  Member -> Cardinality [label="sourceCardinality";dir=both;arrowtail=diamond;arrowhead=open;headlabel="?"];
  Member -> Classifier [label="targetClassifier";dir=both;arrowtail=odiamond;arrowhead=open];
  Member -> Cardinality [label="targetCardinality";dir=both;arrowtail=diamond;arrowhead=open;headlabel="?"];

  integer [shape=rectangle;style=filled;color=lightgrey;label="xsd:nonNegativeInteger"];
  
  Cardinality -> integer [label="owl:maxCardinality";dir=both;arrowtail=diamond;arrowhead=open;headlabel="?"];
  Cardinality -> integer [label="owl:minCardinality";dir=both;arrowtail=diamond;arrowhead=open];

  Variant -> integer [label="hasValue";dir=both;arrowtail=diamond;arrowhead=open];
}
#+END_SRC

#+CAPTION: OWL Ontology
#+RESULTS: fig:owl-ontology
[[file:owl-ontology.png]]

Figure [[fig:owl-ontology]] uses some notation elements from UML, although not a UML diagram itself. 
For a higher resolution version, [[file:owl-ontology.png][click here]].

1. Open triangular arrow heads correspond to the RDF Schema =subClassOf= relationship.
2. Filled diamonds correspond to composite associations, or strong ownership.
3. Open diamonds correspond to aggregate associations, or weak ownership.

** Classes

#+NAME: lst:owl-module
#+CAPTION: OWL: Top-Level Module
#+BEGIN_SRC ttl
:Module rdf:type owl:Class ;
    skos:prefLabel "Module"@en .
#+END_SRC


#+NAME: lst:owl-classifiers
#+CAPTION: OWL: Classifiers, or Types
#+BEGIN_SRC ttl
:Classifier rdf:type owl:Class
    skos:prefLabel "Classifier"@en ;
    skos:altLabel "Type"@en .

:Structure rdf:type owl:Class ;
    rdfs:subClassOf :Classifier ;
    skos:prefLabel "Structure"@en ;
    skos:altLabel "Struct"@en ;
    skos:altLabel "Record"@en .
    
:Entity rdf:type owl:Class ;
    rdfs:subClassOf :Structure ;
    skos:prefLabel "Entity"@en ;
    skos:altLabel "Independent Entity" .
    
:Event rdf:type owl:Class ;
    rdfs:subClassOf :Structure ;
    skos:prefLabel "Event"@en ;
    skos:altLabel "Entity Event"@en .
    
:Enumeration rdf:type owl:Class ;
    rdfs:subClassOf :Classifier .
    
:Datatype rdf:type rdfs:Datatype ;
    rdfs:subClassOf :Classifier ;
    skos:prefLabel "Datatype"@en ;
    skos:altLabel "Data Type"@en .
    
:Unknown rdf:type owl:Class ;
    skos:prefLabel "Unknown" ;
    skos:altLabel "Unknown Type"@en .
#+END_SRC


#+NAME: lst:owl-classifier-parts
#+CAPTION: OWL: Classifier Related Classes
#+BEGIN_SRC ttl
:Group rdf:type owl:Class ;
    skos:prefLabel "Member Group"@en .

:Member rdf:type owl:Class ;
    skos:prefLabel "Member"@en .

:Cardinality rdf:type owl:Class .

:Variant rdf:type owl:Class .
#+END_SRC

** Object Properties

#+NAME: lst:owl-module-object-properties
#+CAPTION: OWL: Module Object Properties
#+BEGIN_SRC ttl
:hasDefinition rdf:type owl:ObjectProperty ;
    rdfs:domain :Module ;
    rdfs:Range  :Classifier ;
    owl:inverseOf :isDefinedBy ;
    skos:prefLabel "module has definition"@en .

:isDefinedBy  rdf:type owl:ObjectProperty ;
    rdfs:isSubPropertyOf rfs:isDefineBy ;
    rdfs:domain :Classifier ;
    rdfs:Range  :Module ;
    skos:prefLabel "defined by module" .
#+END_SRC

Properties concerning structured types.

#+NAME: lst:owl-classifier-object-properties
#+CAPTION: OWL: Classifier Object Properties
#+BEGIN_SRC ttl
:hasGroup rdf:type owl:ObjectProperty ;
    rdfs:Structure ;
    rdfs:range :Group .
    
:hasVariant rdf:type owl:ObjectProperty ;
    rdfs:Domain :Enumeration ;
    rdfs:Range  :Variant ;
    owl:inverseOf :isVariantOf.
    
:isVariantOf rdf:type owl:ObjectProperty ;
    rdfs:Domain :Variant ;
    rdfs:Range  :Enumeration ;
   
:sourceCardinality rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
    
:targetCardinality rdf:type owl:ObjectProperty  ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
    
:targetClassifier rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range  :Classifier .
    
:baseDatatype rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf owl:onDatatype ;
    rdfs:Domain :Datatype ;
    rdfs:Range  :Datatype .
    
:eventSource rdf:type owl:ObjectProperty ;
    rdfs:Domain :Event ;
    rdfs:Range  :Entity ;
    owl:inverseOf :emitsEvent .
    
:emitsEvent rdf:type owl:ObjectProperty ;
    rdfs:Domain :Entity ;
    rdfs:Range  :Event .
#+END_SRC

Properties concerning structured type members

#+NAME: lst:owl-classifier-member-properties
#+CAPTION: OWL: Classifier Member Properties
#+BEGIN_SRC ttl
:hasMember rdf:type owl:ObjectProperty ;
    rdfs:Range :Member ;
    owl:inverseOf :isMemberOf .

:isMemberOf rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member .

:hasIdentifyingMember rdf:type owl:ObjectProperty ;
    rdf:type owl:FunctionalProperty ;
    rdfs:subPropertyOf :hasMember ;
    rdfs:Domain :Entity .
    
:hasCompositeMember rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf :hasMember ;
    rdfs:Domain owl:UnionOf ( :Structure :Group ) .
    
:hasReferenceMember rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf :hasMember ;
    rdfs:Domain owl:UnionOf ( :Entity :Group ) .

:targetClassifier rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range owl:UnionOf ( :Classifier :Unknown ) .
#+END_SRC


#+NAME: lst:owl-cardinality-object-properties
#+CAPTION: OWL: Cardinality Object Properties
#+BEGIN_SRC ttl
:sourceCardinality rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
    
:targetCardinality rdf:type owl:ObjectProperty  ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
#+END_SRC

- Groups not yet modeled.
- Cardinality not yet modeled.

** Datatype Properties

#+NAME: lst:owl-variant-value
#+CAPTION: OWL: Variant Value Property
#+BEGIN_SRC ttl
:hasValue rdf:type owl:DatatypeProperty ;
    rdfs:Domain :Variant ;
    rdfs:Range  :xsd:nonNegativeInteger ;
    skos:prefLabel "has value"@en.
#+END_SRC


* Walk-Through Example

The following section walks through the process of model creation and iterative elaboration to add detail as domain
experts provide more information. In our example we will build a domain model for a vehicle rental company. So, as you
might imagine we can start the model with some pretty obvious entities, but with no detail beyond their names. Listing
[[lst:example-first-pass]] is this first-pass domain model.

#+NAME: lst:example-first-pass
#+CAPTION: Rentals Concepts (First Pass)
#+BEGIN_SRC sdml :cmdline draw --diagram concepts :file ./rentals-concept-1.svg :exports both :noweb yes
module rentals is

  entity Vehicle

  entity Location

  entity Customer

  entity Booking

end
#+END_SRC

The =sdml= tool can be used to generate a concept diagram, a high-level view of only the entities in the model and their
relationships. The following command-line will generate figure [[fig:example-first-pass]] from listing
[[lst:example-first-pass]].

#+BEGIN_EXAMPLE
sdml draw --diagram concepts \
          --output-format svg \
          --output-file docs/rentals-concept-1.svg \
          docs/rental-1.sdm
#+END_EXAMPLE

#+NAME: fig:example-first-pass
#+CAPTION: Rentals Concepts (First Pass)
#+RESULTS: lst:example-first-pass
[[file:./rentals-concept-1.svg]]

Figure [[lst:example-second-pass]] is the second-pass at our model, adding relationships from the ~Booking~ entity to the
~Customer~, ~Location~, and  ~Vehicle~ entities. Adding a body to the ~Booking~ entity, between =is= … =end=, requires the entity
specify an identifier. To allow the addition of ~bookingCode~ without spending time on the details of it's type the
keyword ~unknown~ is used to defer the type until later.

Additionally, the ~vehicle~ relationship specifies a new cardinality overriding the usual =0..= with =0..1=.

#+NAME: lst:example-second-pass
#+CAPTION: Rentals Basic Relationships
#+BEGIN_SRC sdml :cmdline draw --diagram concepts :file ./rentals-concept-2.svg :exports both :noweb yes
module rentals is

  entity Vehicle

  entity Location

  entity Customer

  entity Booking is
    identity bookingCode -> unknown

    ref vehicle -> {0..1} Vehicle
    ref from -> Location
    ref customer -> Customer
  end

end
#+END_SRC

Re-running the =sdml= tool on listing [[lst:example-second-pass]] will result in the relationships added, as shown in figure
[[fig:example-second-pass]].

#+NAME: fig:example-second-pass
#+CAPTION: Rentals Basic Relationships
#+RESULTS: lst:example-second-pass
[[file:./rentals-concept-2.svg]]

In the next edit of our rentals model we see some additions:

1. The use of =import= to use the ~VehicleIdentificationNumber~ data type from the ~cids~ (Common Identifiers) model.
1. The new entity ~Class~ to model the rental class of a vehicle.
1. ~Vehicle~ now has an identifier, a relationship to the new ~Class~ entity, and a relationship to ~Location~.
1. ~Booking~ also has a relationship to the new ~Class~ entity.
1. We demonstrate the non-range cardinality notation, ={1}=, which is a shortcut for the range =1..1=.

#+NAME: lst:example-third-pass
#+CAPTION: Rentals More Detail
#+BEGIN_SRC sdml :exports code :noeval
module rentals is

  import cids:VehicleIdentificationNumber

  entity Class

  entity Vehicle is
    identity vin -> cids:VehicleIdentificationNumber

    ref rentalClass -> {1} Class
    ref onProperty -> {0..1} Location
  end

  entity Location

  entity Customer

  entity Booking is
    identity bookingCode -> unknown

    ref bookingClass -> {1} Class
    ref vehicle -> {0..1} Vehicle
    ref from -> Location
    ref customer -> {1} Customer
  end

end
#+END_SRC

As usual we generate the concept diagram in figure [[fig:example-third-pass]] from listing [[lst:example-third-pass]].

#+NAME: fig:example-third-pass
#+BEGIN_SRC sdml :cmdline draw --diagram concepts :file ./rentals-concept-3.svg :exports results :noweb yes
<<lst:example-third-pass>>
#+END_SRC

#+CAPTION: Rentals More Detail
#+RESULTS: fig:example-third-pass
[[./rentals-concept-3.svg]]

#+NAME: lst:example-fourth-pass
#+CAPTION: Rentals Non-Entity Detail
#+BEGIN_SRC sdml :cmdline draw --diagram concepts :file ./rentals-concept-4.svg :exports both :noweb yes
module rentals is

  import [cids:VehicleIdentificationNumber cids:Uuid]
  import [xsd:date xsd:string]

  entity Class

  entity Vehicle is
    identity vin -> cids:VehicleIdentificationNumber

    ref rentalClass -> {1} Class
  end

  entity Location is
    identity id -> cids:Uuid

    address -> {1} Address
  end

  entity Customer is
    identity id -> cids:Uuid

    contactAddress -> {1} Address
    driverLicense -> {0..1} LicenseInformation
  end

  structure Address

  structure LicenseInformation is
    number -> xsd:string
    state -> xsd:string
    expiration -> xsd:date
  end

  entity Booking is
    identity bookingCode -> unknown

    ref bookingClass -> {1} Class
    ref vehicle -> {0..1} Vehicle
    ref pickup -> {1} Location
    pickupDate -> {1} xsd:date
    ref dropoff -> {1} Location
    dropoffDate -> {1} xsd:date
    ref customer -> {1} Customer
  end

end
#+END_SRC

As usual we generate the concept diagram in figure [[fig:example-fourth-pass]] from listing [[lst:example-fourth-pass]].

#+NAME: fig:example-fourth-pass
#+CAPTION: Rentals Non-Entity Detail
#+RESULTS: lst:example-fourth-pass
[[./rentals-concept-4.svg]]

#+BEGIN_EXAMPLE
sdml draw --diagram erd \
          --output-format svg \
          --output-file docs/rentals-concept-4.svg \
          docs/rental-4.sdm
#+END_EXAMPLE

#+NAME: lst:example-fourth-pass-erd
#+BEGIN_SRC sdml :cmdline draw --diagram erd :file ./rentals-erd-4.svg :exports results :noweb yes
<<lst:example-third-pass>>
#+END_SRC

#+NAME: fig:example-fourth-pass-erd
#+CAPTION: Rentals ERD Diagram
#+RESULTS: lst:example-fourth-pass-erd
[[./rentals-erd-4.svg]]


* Transforms

TBD


* Implementation and Tools

#+NAME: fig:implementation-overview
#+BEGIN_SRC dot :file implementation-overview.png :exports results
digraph G {
    bgcolor="transparent";
    rankdir="TB";
    fontname="Helvetica,Arial,sans-serif";
    node [fontname="Helvetica,Arial,sans-serif"; fontsize=10];
    edge [fontname="Helvetica,Arial,sans-serif"; fontsize=9; fontcolor="dimgrey"; labelfontcolor="blue"; labeldistance=2.0];

    subgraph cluster_0 {
        label = "Core Library";
        grammar [label="Grammar\nDefinition"];
        parser [label="Parser\nDylib"];
        rust [label="Rust\nBindings"];
        npm [label="Node\nBindings"];
        wasm [label="WASM\nBindings"];

        grammar -> parser;
        parser -> rust;
        parser -> npm;
        parser -> wasm;
    }

    treesit [shape=rect; label="Tree-Sitter\nC Library"];
    treesit -> grammar;

    subgraph cluster_1 {
        label = "Emacs Support";
        emode [label="Editing Mode"];
        spell [label="Spell Checker"];
        flycheck [label="Flycheck"];
        emode -> spell;
        emode -> flycheck;

        parser -> emode;
    }

    ets [shape=rect; label="Emacs\nTree-Sitter"];
    ets_hl [shape=rect; label="Tree-Sitter\nHighlighter"];
    ets_indent [shape=rect; label="Tree-Sitter\nIndenter"];
    ets_fold [shape=rect; label="Tree-Sitter\nFolder"];

    treesit -> ets;
    ets -> ets_hl;
    ets -> ets_indent;
    ets -> ets_fold;

    ets_hl -> emode;
    ets_indent -> emode;
    ets_fold -> emode;

    subgraph cluster_2 {
        label = "Command-Line Tool";
        api [label="API"];
        fmt [label="Formatter"];
        linter [label="Linter"];
        diagrams [label="Diagrammer"];

        rust -> api;
        api -> fmt;
        api -> linter;
        api -> diagrams;
    }
}
#+END_SRC
 
#+CAPTION: Implementation Overview
#+RESULTS: fig:implementation-overview
[[file:implementation-overview.png]]

** Core Library

- Source at [[https://github.com/johnstonskj/tree-sitter-sdml][Github]]

Build.

#+BEGIN_EXAMPLE
git clone https://github.com/johnstonskj/tree-sitter-sdml
#+END_EXAMPLE

#+BEGIN_EXAMPLE
make setup
#+END_EXAMPLE

#+BEGIN_EXAMPLE
make build
#+END_EXAMPLE

*Bindings:*

- Node binding, published to [[https://www.npmjs.com/package/tree-sitter-sdml][npm.js]]
- Rust binding, published to [[https://crates.io/crates/tree-sitter-sdml][crates.io]]
 
** Command-Line Tool

- Source at [[https://github.com/johnstonskj/rust-sdml][Github]]
- Published to [[https://crates.io/crates/sdml][crates.io]]

*** Projects, Domains, and Modules

TBD

*** Module Resolution

By convention the CLI expects /projects/ to have the following organization.

#+BEGIN_EXAMPLE
domain-root/
  |--sub-domain/
  |    |-- sub-domain.sdml
  |    '-- other.sdml
  |--other-sub-domain/
  '--resolver.yaml
#+END_EXAMPLE

#+BEGIN_SRC sdml :exports code :noeval
module subDomain is

  import skos:prefLabel

  import other:Something

  import otherSubDomain

  import somethingElse

end
#+END_SRC

*** Resolver File

#+BEGIN_SRC yaml
version: 1
base: https://example.com/some/base
prefixes:
  somethingElse:
    iri: ...
    local: ...
    override: ...
#+END_SRC

** Emacs Support

- Emacs [[https://github.com/johnstonskj/emacs-sdml-mode][sdml-mode]]
  
*** Emacs (< 29)

Follow the directions in the /read-me/ file for the Emacs [[https://github.com/johnstonskj/emacs-sdml-mode][tree-sitter]] package.



** Other Editors

*** Neovim

TBD

*** VSCode

Try here: https://github.com/georgewfraser/vscode-tree-sitter


* Appendix: Surface Syntax to RDF

TBD

** Whitespace

Whitespace present in the surface syntax has *no* effect on the corresponding RDF.

** Comments

Comments present in the surface syntax are *not* translated into the corresponding RDF.;

** Identifiers

Identifiers for modules and type definitions are appended to the base IRI of the module resource, making individual
types within a module directly addressable.

*Example:*

Given a resource retrieved from =https://example.com/v/example/= and containing the following:

#+BEGIN_SRC sdml :exports code :noeval
module example is
end
#+END_SRC

The module within has the IRI identifier =https://example.com/v/example/example=.

However, if the module overrides the retrieved location using =xml:base=, as follows:

#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xml:base
  @xml:base = <https://example.org/langs/Example#>
end
#+END_SRC

The module within this resource now has the IRI identifier =https://example.org/langs/Example#example=.

The remainder of this section will use example modules with =xml:base= to make identifier IRIs more easily understood.

** Values

*** <<sec:mapping-values>> Simple Value Literals

#+NAME: tbl:value-literals
#+CAPTION: Summary of Value Literals
| SDML Type     | Underlying Type | Value Space                                                  | Lexical Space  |
|---------------+-----------------+--------------------------------------------------------------+----------------|
| =boolean=       | =xsd:boolean=     | The values =true= and =false=                                    | =true= and =false= |
| =decimal=       | =xsd:decimal=     | A 128-bit representation of a fixed-precision decimal number | [[https://www.w3.org/TR/xmlschema-2/#decimal][XML Schema]]     |
| =double=        | =xsd:double=      | An IEEE double-precision 64-bit floating point type          | [[https://www.w3.org/TR/xmlschema-2/#double][XML Schema]]     |
| =integer=       | =xsd:integer=     | A signed 64-bit integer                                      |                |
| =iri_reference= | =xsd:AnyURI=      | Represents a Uniform Resource Identifier Reference (URI)     | [[https://www.w3.org/TR/xmlschema-2/#anyURI][XML Schema]]     |
| =string=        | =rdfs:langString= |                                                              | [[https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal][RDF]]            |

*** List Literals

*Example:*

Given the following list literal:

#+BEGIN_SRC sdml :exports code :noeval
module example is
  @skos:altLabel = [ "yes" "no" "maybe" ]
end
#+END_SRC

The generated RDF consists of separate statements for each value in the list.

#+BEGIN_SRC ttl
:thing skos:altLabel "yes" .
:thing skos:altLabel "no" .
:thing skos:altLabel "maybe" .
#+END_SRC

For clarity and brevity this is usually written in Turtle as an object list (Turtle [[https://www.w3.org/TR/turtle/#object-lists][2.3 Object Lists]]):

#+BEGIN_SRC ttl
:thing skos:altLabel "yes", "no", "maybe" .
#+END_SRC

Currently there is no mapping from the surface syntax to list values, that is an RDF Collection (Turtle [[https://www.w3.org/TR/turtle/#collections][2.8 Collections]])
which constructs a list using the =rdf:first= and =rdf:rest= predicates. This would result in the following RDF:

#+BEGIN_SRC ttl
:thing skos:altLabel ( "yes" "no" "maybe" ) .
#+END_SRC

*** Value Constructors

A value constructor allows for the precise specification of a datatype for a literal.

#+BEGIN_SRC sdml :exports code :noeval
module example is
  @sdml:defaultVariant = xsd:nonNegativeInteger(0)
end
#+END_SRC

#+BEGIN_SRC ttl
:thing sdml:defaultVariant "0"^^xsd:nonNegativeInteger .
#+END_SRC

** Modules

*Example with Implied Base:*

#+BEGIN_SRC sdml :exports code :noeval
module example is end
#+END_SRC


#+BEGIN_SRC ttl
@base <https://example.com/v/example/> .
@prefix : <https://example.com/v/example/> .
@prefix sdml: <https://api.amazonadvertising.com/domain-model> .

:example rdf:type sdml:Module .
#+END_SRC

*Example with Explicit Base:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xml:base
  @xml:base = <https://example.org/langs/Example#>
end
#+END_SRC


#+BEGIN_SRC ttl
@base <https://example.org/langs/Example#> .
@prefix : <https://example.org/langs/Example#> .
@prefix sdml: <https://api.amazonadvertising.com/domain-model> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .

:example rdf:type sdml:Module .
#+END_SRC

** Imports

*Example with Implicit Location:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xml
end
#+END_SRC


*Example with Explicit Location:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xml from <file:///usr/local/share/schema/xml.ttl>
end
#+END_SRC

** Annotations
** Data Type Definition

*Example:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  datatype name <- xsd:string
end
#+END_SRC

#+BEGIN_SRC ttl
:name rdf:type rdfs:Datatype ;
    owl:onDatatype xsd:string .
#+END_SRC

*Example with Restrictions:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  datatype name <- xsd:string is
    @xsd:minLength = 5
    @xsd:maxLength = 25
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:name rdf:type rdfs:Datatype ;
    owl:onDatatype xsd:string ;
    owl:withRestrictions (
        [ xsd:minLength "5"^^xsd:nonNegativeInteger ]
        [ xsd:maxLength "25"^^xsd:nonNegativeInteger ]
    ) .
#+END_SRC

** Entity Definition

*Example Empty Entity:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person
end
#+END_SRC

#+BEGIN_SRC ttl
:Person rdf:type sdml:Entity .
#+END_SRC

*Example Entity with Identity:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    identity id -> PersonId
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:Person rdf:type sdml:Entity ;
    :hasIdentifyingMember [
        rdfs:label "id" ;
        :targetClassifier :Person ;
    ] .
#+END_SRC

#+BEGIN_SRC ttl
:Person_id rdf:type sdml:Member ;
    rdfs:label "id" ;
    :targetClassifier :Person .

:Person rdf:type sdml:Entity ;
    :hasIdentifyingMember :Person_id .
#+END_SRC

*Example Entity with By-Value Member:*

TBD

*Example Entity with By-Reference Member:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    identity id -> PersonId

    ref contact {0..} -> {0..2} Person is
      @dc:description = "Emergency contact person"
    end
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:Person rdf:type sdml:Entity ;
    :hasReferenceMember [
        rdfs:label "contact" ;
        :targetClassifier :Person ;
        :sourceCardinality [
            owl:minCardinality 0 ;
        ] ;
        :targetCardinality [
            owl:minCardinality 0 ;
            owl:maxCardinality 2 ;
        ] ;
        dc::description "Emergency contact person"
    ] .
#+END_SRC

*Example Entity with Group:*

TBD

#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Vehicle is
    identity vin -> csids:VehicleIdentificationNumber

    group
      @skos:prefLabel = "Identification"
      make -> xsd:string
      model -> xsd:string
    end
  end
end
#+END_SRC

** Enumeration Definition

*Example Empty Enumeration:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit
end
#+END_SRC

#+BEGIN_SRC ttl
:DistanceUnit rdf:type sdml:Enumeration .
#+END_SRC

*Example Enumeration with Variants:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit is
    Meter = 1
    Foot = 2
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:DistanceUnit rdf:type sdml:Enumeration
    :hasVariant [
        rdfs:label "Meter" ;
        :hasValue 1 
    ] ,
    [
        rdfs:label "Foot" ;
        :hasValue 2
    ] .
#+END_SRC

** Event Definition

*Example Empty Event:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person
end
#+END_SRC

#+BEGIN_SRC ttl
:PersonNameChanged rdf:type sdml:Event ;
    sdml:eventSource :Person .
#+END_SRC

*Example Event with Members:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person is
    ;; identifier members will be copied from Person 
    fromValue -> Name
    toValue -> Name
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:PersonNameChanged rdf:type sdml:Event ;
    sdml:eventSource :Person ;
    :hasMember [
        rdfs:Label "personId" ;
        :targetClassifier :Person
    ] ,
    [
        rdfs:Label "fromValue" ;
        :targetClassifier :Name
    ] ,
    [
        rdfs:Label "toValue" ;
        :targetClassifier :Name
    ] .
#+END_SRC

** Structure Definition

*Example Empty Structure:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length
end
#+END_SRC

#+BEGIN_SRC ttl
:Length rdf:type sdml:Structure ;
    rdfs:isDefinedBy :module .
#+END_SRC

*Example Structure with Annotation:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:Length rdf:type sdml:Structure ;
    skos:prefLabel "Length"@en .
#+END_SRC

*Example Structure with Members:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en

    value -> Decimal
    unit -> DistanceUnit
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:Length rdf:type sdml:Structure ;
    skos:prefLabel "Length"@en .
    :hasMember [
        rdfs:label "value" ;
        :targetClassifier :Decimal ;
    ] ,
    [
        rdfs:label "unit" ;
        :targetClassifier :DistanceUnit ;
    ] .
#+END_SRC

*Example Structure with Groups:*

#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Account is
    @skos:prefLabel = "Customer Account"@en
    group
      @skos:prefLabel = "Metadata"@en
      created -> xsd:dateTime
    end
    group
      @skos:prefLabel = "Customer Information"@en
      ref customer -> {1..1} Customer
    end
  end
end
#+END_SRC


* <<app:domain-modeling>> Appendix: Domain Modeling

There is often confusion around the use of the term /Domain Model/ especially in regard to terms such as /Data Model/, /Class
Model/, /Schema/ and more. This short noteappendix is an attempt to clarify the terminology and how the relevant modeling
efforts are undertaken. This is not intended as an exhaustive review of modelling approaches, standards, or technologies
and neither does it make any judgement as to the usefulness of any approach or technology.

** Model Terminology

A model is an informative representation of an object, person or system. The term originally denoted the plans of a
building in late 16th-century English, and derived via French and Italian ultimately from Latin modulus, a measure. As
is common in software development the term model is overloaded and it's use can lead to confusion as people have
different expectations and assumptions regarding what kind of model is being discussed. To this end we introduce some
terminology here that, if simply used as model qualifiers, helps to disambiguate the purpose of any particular model.

For now we will use the following classification to partition the major purpose of different model instances.

- *Data*: A data model in software engineering is a representation of concepts and the relationships, constraints, rules,
  and operations to specify data semantics for a chosen domain of discourse. Typically it specifies relations between
  kinds of things, but may also include relations with individual things. It can provide sharable, stable, and organized
  structure of information requirements or knowledge for the domain context.
- *Behavior*: Behavioral languages are designed to describe the observable behavior of complex systems consisting of
  components that execute concurrently. These languages focus on the description of key concepts such as: concurrency,
  nondeterminism, synchronization, and communication.
- *Process*: [Business] process modeling (BPM) in business process management and systems engineering is the activity of
  representing processes of an enterprise, so that the current business processes may be analyzed, improved, and
  automated.

A common framework for defining the /level/ (usually of abstraction) inherent to a model are the three /perspectives/
introduced by ANSI in 1975.

- *Conceptual*: In the field of computer science a conceptual model aims to express the meaning of terms and concepts used
  by domain experts to discuss the problem, and to find the correct relationships between different concepts. The
  conceptual model attempts to clarify the meaning of various, usually ambiguous terms, and ensure that confusion caused
  by different interpretations of the terms and concepts cannot occur.
- *Logical*: A logical data model or logical schema is a data model of a specific problem domain expressed independently
  of a particular database management product or storage technology (physical data model) but in terms of data
  structures such as relational tables and columns, object-oriented classes, or XML tags. This is as opposed to a
  conceptual data model, which describes the semantics of an organization without reference to technology.
- *Physical*: A physical data model (or database design) is a representation of a data design as implemented, or intended
  to be implemented, in a database management system. In the lifecycle of a project it typically derives from a logical
  data model, though it may be reverse-engineered from a given database implementation.
  
With these two classifications we can construct a simple grammar for the qualification of the term /model/:

#+BEGIN_SRC bnf
<perspective>      ::= "conceptual" | "logical" | "physical"

<scope>            ::= "data" | "behavior" | "process"

<model-reference>  ::= perspective scope "model"
#+END_SRC

** Modeling Language/Notation

There have been a number of modeling techniques, notations, and languages over the years. The following table describes
those in common use today. It is worth noting that after OMG standardization there are common meta-model underpinnings
for UML and BPMN.

|            | *Data*                            | *Behavior*                     | *Process*          |
| *Conceptual* | UML^1, Concept Map, Semantic Net | UML^2, Flowchart              | UML^3, BPMN, EPC^4 |
| *Logical*    | UML^1, EXPRESS, IDEF1X, IE^5      | UML^2                         | BPMN             |
| *Physical*   | UML^1, …                         | UML^6, Statecharts, Petri net |                  |

1. Class and Component diagrams.
2. Sequence, State, and Activity diagrams.
3. Use Case and Activity diagrams.
4. Event-driven Process Chains.
5. Information Engineering (IE) introduced the commonly used /crows-foot/ notation.
6. Action Semantics and action languages.

UML has a built-in extension mechanism with /stereotypes/ and /profiles/ and data modeling concerns are often introduced
with specific extensions such as stereotypes for different key types.

** Domain-Driven Design

Domain-driven design (DDD) is a software design approach focusing on modeling software to match a domain according to
input from that domain's experts. Under domain-driven design, the structure and language of software code (class names,
class methods, class variables) should match the business domain.

Within this approach the /domain/ model is usually a conceptual or logical data model that describes the key entities
that comprise the domain. The representation of this model can be any of the languages described above although UML is
the common. The discipline of domain modeling is unique in it's focus on deriving data/information models directly from
the business and stresses the involvement of domain experts from the business in the development of models. Additionally
the literature describes specific kinds of model entities and their unique semantics, /Entities/, /Value Objects/, /Events/,
and /Aggregates/, etc. which help focus conversations on key modeling concepts such as identity, lifecycle, and ownership.

Thus, a *Domain Model* is a /conceptual/ (UML or Ontology) or /logical/ (UML) /data model/ developed according to a specific
methodology (DDD) and employing a specific meta-language (UML Profile).

Some of the defined kinds, /Repository/, /Factory/, and /Service/ are lower-level concerns and the lack of a clear separation
between different levels of abstraction is one criticism of the method. Additionally terms such as Entity as defined by
DDD is not entirely compatible with the use in pre-existing methods such as E/R modeling.

However, the method's focus on the business and it's vocabulary as the basis for models is valuable in an effort such as
the Universal API where the model will represent our business model in different presentations.


* Appendix: Known URI Prefixes

The following prefixes may be used in import statements without the need to reference their location directly. Either
the namespace URI will be used to retrieve the corresponding resource or a local copy will be used.

#+NAME: tbl:rdf-prefixes
#+CAPTION: List of Known URI Prefixes
| Prefix    | URI                                           |
|-----------+-----------------------------------------------|
| =dbpedia=   | <http://dbpedia.org/resource/>                |
| =dbpprop=   | <http://dbpedia.org/property/>                |
| =dc=        | <http://purl.org/dc/elements/1.1/>            |
| =dcam=      | <http://purl.org/dc/dcam/>                    |
| =dcterms=   | <http://purl.org/dc/terms/>                   |
| =dctype=    | <http://purl.org/dc/dcmitype/>                |
| =foaf=      | <http://xmlns.com/foaf/0.1/>                  |
| =geo=       | <http://www.w3.org/2003/01/geo/wgs84_pos#>    |
| =ldp=       | <http://www.w3.org/ns/ldp#>                   |
| =owl=       | <http://www.w3.org/2002/07/owl#>              |
| =rdf=       | <http://www.w3.org/1999/02/22-rdf-syntax-ns#> |
| =rdfs=      | <http://www.w3.org/2000/01/rdf-schema#>       |
| *=sdml=*    | *<https://github.com/johnstonskj/sdml/>*      |
| =sioc=      | <http://rdfs.org/sioc/ns#>                    |
| =skos=      | <http://www.w3.org/2004/02/skos/core#>        |
| =vcard=     | <http://www.w3.org/2001/vcard-rdf/3.0#>       |
| =vcard2006= | <http://www.w3.org/2006/vcard/ns#>            |
| =void=      | <http://rdfs.org/ns/void#>                    |
| =xml=       | <http://www.w3.org/XML/1998/namespace>        |
| =xsd=       | <http://www.w3.org/2001/XMLSchema#>           |

** Recommended Usage

*** Resource Identification

xml:base

*** Labels and Descriptions

skos, rdfs, dcterms

*** Data Type Restrictions

xsd


* Appendix: Tables of Other Content

#+TOC: figures

#+TOC: tables

#+TOC: listings
