#+TITLE: Simple Domain Modeling Language
#+AUTHOR: Simon Johnston
#+EMAIL: johnstonskj@gmail.com
#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty
# #+INFOJS_OPT: view:t toc:t ltoc:t mouse:underline buttons:0 path:http://thomasf.github.io/solarized-css/org-info.min.js
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <style>img { max-width: 800px; height: auto; }</style>
#+HTML_HEAD: <style>div.figure { text-align: center; }</style>
#+OPTIONS: toc:3

#+BEGIN_SRC emacs-lisp :exports none
(require 'ob-dot)
#+END_SRC


* Introduction

The Simple Domain Modeling Language is a small data-oriented language for constructing, documenting, and reasoning about
a conceptual domain model. The language uses some ideas from [[http://www.uml.org/][UML]] which is often used in the construction of such models
today. However, the goal is to keep the language as small as possible, taking away some options where they don't make
sense or where their use may distract from the major purpose of the model. The model also takes some of the language
from Domain-Driven Design[fn:1], namely the separation of entities (/an object defined not by its attributes, but its
identity/) from value objects (/an immutable object that contains attributes but has no conceptual identity/), simply
termed structures in SDML. This model does not include the following as first-class concepts: /aggregates/, /repositories/,
/factories/, or /services/.

At it's core SDML comprises an /abstract model/ whose structure and semantics are described by an [[https://www.w3.org/OWL/][OWL]] ([[https://www.w3.org/RDF/][RDF]]) ontology, and a
/surface syntax/ for editing and sharing concrete models. This document covers both the OWL and SDML representations and
the correspondence between them, however the primary focus of the documentation is the surface syntax as most users will
be interacting with it alone. Figure [[fig:model-overview]] shows the relationship between these high-level components. 

#+NAME: fig:model-overview
#+BEGIN_SRC dot :file sdml-overview.png :exports results
digraph G {
  bgcolor="transparent";
  rankdir="LR";
  node [fontsize=10];
  edge [fontsize=9; fontcolor=darkgrey];
  
  abstract [shape=ellipse; label="Abstract\nModel"];

  rdf [shape=ellipse; label="RDF/OWL"];
  sdml [shape=ellipse; label="Surface\nSyntax"];  
  abstract -> rdf [label="semantics"];  
  abstract -> sdml [label="syntax"];

  concrete [shape=ellipse; style=dotted; label="Concrete\nModel"];
  rdf -> concrete [arrowtail=open; dir=back; style=dotted; label="conforms-to"];
  sdml -> concrete [arrowtail=open; dir=back; style=dotted; label="expressed-in"];
}
#+END_SRC

#+CAPTION: Model Overview
#+RESULTS: fig:model-overview
[[file:sdml-overview.png]]

One element that is not included in figure [[fig:model-overview]] as it is primarily an implementation decision, is that the
reference implementation for SDML is provided as a [[https://tree-sitter.github.io/tree-sitter/][Tree-Sitter]] package. While generated tree-sitter parsers are not
intended to be fast, or to be part of a compilation processes they do provide a multitude of language bindings, and a
concrete syntax tree allowing easy development of the relatively simple tools required for SDML usage. 

Figure [[fig:model-transforms]] demonstrates another key element of a /Model-Driven Development/[fn:2] style, the transformation
between models and between models and other development artifacts.

#+NAME: fig:model-transforms
#+BEGIN_SRC dot :file sdml-transforms.png :exports results
digraph G {
  bgcolor="transparent";
  rankdir="LR";
  node [fontsize=10];
  edge [fontsize=9; fontcolor=darkgrey];

  abstract [shape=ellipse; label="Abstract\nModel"];

  transform [shape=ellipse; label="Transformation"];
  transform -> abstract [label="source"];

  tsq [shape=ellipse; label="Tree-Sitter\nQueries"];
  transform -> tsq [label="using"];

  other [shape=ellipse; label="Artifact\nModel"];
  transform -> other [label="target"];
}
#+END_SRC

#+CAPTION: Model Transformations
#+RESULTS: fig:model-transforms
[[file:sdml-overview.png]]

# ----- Footnotes

[fn:1] [[https://en.wikipedia.org/wiki/Domain-driven_design][Domain-Driven Design]], Wikipedia
[fn:2] [[https://en.wikipedia.org/wiki/Model-driven_engineering][Model-Driven Development]], Wikipedia


* RDF Abstract Model

Why RDF? ...

Figure [[fig:owl-ontology]] is an overview of the OWL Ontology, 

#+NAME: fig:owl-ontology
#+BEGIN_SRC dot :file owl-ontology.png :exports results
digraph G {
  bgcolor="transparent";
  rankdir="LR";
  node [fontsize=10];
  edge [fontsize=9; fontcolor=darkgrey];

  Module [shape=ellipse;penwidth=2.0;color=blue;labelcolor=blue];
  Cardinality [shape=ellipse];
  Classifier [shape=ellipse];
  Entity [shape=ellipse];
  Enumeration [shape=ellipse];
  Event [shape=ellipse];
  Group [shape=ellipse];
  Member [shape=ellipse];
  Structure [shape=ellipse];
  Variant [shape=ellipse];
  Datatype [shape=ellipse;label="rdfs:Datatype"];

  Module -> Classifier [label="hasDefinition";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];

  Structure -> Classifier [label="rdfs:subClassOf";arrowhead=empty];
  Entity -> Structure [label="rdfs:subClassOf";arrowhead=empty];
  Enumeration -> Classifier [label="rdfs:subClassOf";arrowhead=empty];
  Event -> Structure [label="rdfs:subClassOf";arrowhead=empty];
  Datatype -> Classifier [label="rdfs:subClassOf";arrowhead=empty];

  Event -> Entity [label="eventSource";dir=both;arrowtail=odiamond;arrowhead=open];

  Datatype -> Datatype [label="baseDatatype";dir=both;arrowtail=odiamond;arrowhead=open];

  Structure -> Group [label="hasGroup";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];
  Structure -> Member [label="hasMember";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];
  Entity -> Member [label="hasIdentifier";dir=both;arrowtail=diamond;arrowhead=open;headlabel="1"];

  Group -> Member [label="hasMember";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];

  Enumeration -> Variant [label="hasVariant";dir=both;arrowtail=diamond;arrowhead=open;headlabel="*"];

  Member -> Cardinality [label="sourceCardinality";dir=both;arrowtail=diamond;arrowhead=open;headlabel="?"];
  Member -> Classifier [label="targetClassifier";dir=both;arrowtail=odiamond;arrowhead=open];
  Member -> Cardinality [label="targetCardinality";dir=both;arrowtail=diamond;arrowhead=open;headlabel="?"];

  integer [shape=rectangle;style=filled;color=lightgrey;label="xsd:nonNegativeInteger"];
  
  Cardinality -> integer [label="owl:maxCardinality";dir=both;arrowtail=diamond;arrowhead=open;headlabel="?"];
  Cardinality -> integer [label="owl:minCardinality";dir=both;arrowtail=diamond;arrowhead=open];

  Variant -> integer [label="hasValue";dir=both;arrowtail=diamond;arrowhead=open];
}
#+END_SRC

#+CAPTION: OWL Ontology
#+RESULTS: fig:owl-ontology
[[file:owl-ontology.png]]

Figure [[fig:owl-ontology]] uses some notation elements from UML, although not a UML diagram itself. 
For a higher resolution version, [[file:owl-ontology.png][click here]].

1. Open triangular arrow heads correspond to the RDF Schema =subClassOf= relationship.
2. Filled diamonds correspond to composite associations, or strong ownership.
3. Open diamonds correspond to aggregate associations, or weak ownership.

** Classes

#+NAME: lst:owl-module
#+CAPTION: OWL: Top-Level Module
#+BEGIN_SRC ttl
:Module rdf:type owl:Class ;
    skos:prefLabel "Module"@en .
#+END_SRC


#+NAME: lst:owl-classifiers
#+CAPTION: OWL: Classifiers, or Types
#+BEGIN_SRC ttl
:Classifier rdf:type owl:Class
    skos:prefLabel "Classifier"@en ;
    skos:altLabel "Type"@en .

:Structure rdf:type owl:Class ;
    rdfs:subClassOf :Classifier ;
    skos:prefLabel "Structure"@en ;
    skos:altLabel "Struct"@en ;
    skos:altLabel "Record"@en .
    
:Entity rdf:type owl:Class ;
    rdfs:subClassOf :Structure ;
    skos:prefLabel "Entity"@en ;
    skos:altLabel "Independent Entity" .
    
:Event rdf:type owl:Class ;
    rdfs:subClassOf :Structure ;
    skos:prefLabel "Event"@en ;
    skos:altLabel "Entity Event"@en .
    
:Enumeration rdf:type owl:Class ;
    rdfs:subClassOf :Classifier .
    
:Datatype rdf:type rdfs:Datatype ;
    rdfs:subClassOf :Classifier ;
    skos:prefLabel "Datatype"@en ;
    skos:altLabel "Data Type"@en .
    
:Unknown rdf:type owl:Class ;
    skos:prefLabel "Unknown" ;
    skos:altLabel "Unknown Type"@en .
#+END_SRC


#+NAME: lst:owl-classifier-parts
#+CAPTION: OWL: Classifier Related Classes
#+BEGIN_SRC ttl
:Group rdf:type owl:Class ;
    skos:prefLabel "Member Group"@en .

:Member rdf:type owl:Class ;
    skos:prefLabel "Member"@en .

:Cardinality rdf:type owl:Class .

:Variant rdf:type owl:Class .
#+END_SRC

** Object Properties

#+NAME: lst:owl-module-object-properties
#+CAPTION: OWL: Module Object Properties
#+BEGIN_SRC ttl
:hasDefinition rdf:type owl:ObjectProperty ;
    rdfs:domain :Module ;
    rdfs:Range  :Classifier ;
    owl:inverseOf :isDefinedBy ;
    skos:prefLabel "module has definition"@en .

:isDefinedBy  rdf:type owl:ObjectProperty ;
    rdfs:isSubPropertyOf rfs:isDefineBy ;
    rdfs:domain :Classifier ;
    rdfs:Range  :Module ;
    skos:prefLabel "defined by module" .
#+END_SRC

Properties concerning structured types.

#+NAME: lst:owl-classifier-object-properties
#+CAPTION: OWL: Classifier Object Properties
#+BEGIN_SRC ttl
:hasGroup rdf:type owl:ObjectProperty ;
    rdfs:Structure ;
    rdfs:range :Group .
    
:hasVariant rdf:type owl:ObjectProperty ;
    rdfs:Domain :Enumeration ;
    rdfs:Range  :Variant ;
    owl:inverseOf :isVariantOf.
    
:isVariantOf rdf:type owl:ObjectProperty ;
    rdfs:Domain :Variant ;
    rdfs:Range  :Enumeration ;
   
:sourceCardinality rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
    
:targetCardinality rdf:type owl:ObjectProperty  ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
    
:targetClassifier rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range  :Classifier .
    
:baseDatatype rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf owl:onDatatype ;
    rdfs:Domain :Datatype ;
    rdfs:Range  :Datatype .
    
:eventSource rdf:type owl:ObjectProperty ;
    rdfs:Domain :Event ;
    rdfs:Range  :Entity ;
    owl:inverseOf :emitsEvent .
    
:emitsEvent rdf:type owl:ObjectProperty ;
    rdfs:Domain :Entity ;
    rdfs:Range  :Event .
#+END_SRC

Properties concerning structured type members

#+NAME: lst:owl-classifier-member-properties
#+CAPTION: OWL: Classifier Member Properties
#+BEGIN_SRC ttl
:hasMember rdf:type owl:ObjectProperty ;
    rdfs:Range :Member ;
    owl:inverseOf :isMemberOf .

:isMemberOf rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member .

:hasIdentifyingMember rdf:type owl:ObjectProperty ;
    rdf:type owl:FunctionalProperty ;
    rdfs:subPropertyOf :hasMember ;
    rdfs:Domain :Entity .
    
:hasCompositeMember rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf :hasMember ;
    rdfs:Domain owl:UnionOf ( :Structure :Group ) .
    
:hasReferenceMember rdf:type owl:ObjectProperty ;
    rdfs:subPropertyOf :hasMember ;
    rdfs:Domain owl:UnionOf ( :Entity :Group ) .

:targetClassifier rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range owl:UnionOf ( :Classifier :Unknown ) .
#+END_SRC


#+NAME: lst:owl-cardinality-object-properties
#+CAPTION: OWL: Cardinality Object Properties
#+BEGIN_SRC ttl
:sourceCardinality rdf:type owl:ObjectProperty ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
    
:targetCardinality rdf:type owl:ObjectProperty  ;
    rdfs:Domain :Member ;
    rdfs:Range  :Cardinality .
#+END_SRC

- Groups not yet modeled.
- Cardinality not yet modeled.

** Datatype Properties

#+NAME: lst:owl-variant-value
#+CAPTION: OWL: Variant Value Property
#+BEGIN_SRC ttl
:hasValue rdf:type owl:DatatypeProperty ;
    rdfs:Domain :Variant ;
    rdfs:Range  :xsd:nonNegativeInteger ;
    skos:prefLabel "has value"@en.
#+END_SRC


* Surface Syntax

The following describes the SDML surface syntax, a syntax intended to look and feel like a programming language but with
extensibility provided by it's underlying RDF and OWL foundation.

** Whitespace and Comments

This grammar chooses to use the JavaScript regular expression character class =\s= which includes the following values,
including all Unicode whitespace.

=/[\f\n\r\t\v\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/=

Comments follow Lisp-like forms, starting with a semi-colon character and continuing to the end of line. Lisp
conventions for single, double, and triple comment characters are useful but in no way enforced.

#+NAME: lst:sdml-ex-comments
#+CAPTION: SDML Comments
#+BEGIN_SRC sdml
; comments start with ';' and go to end of line
#+END_SRC

** Identifiers

An identifier is a string of characters corresponding to the [[https://unicode.org/reports/tr44/#GC_Values_Table][Unicode General Category]] *Lu* (an uppercase letter) or *Ll* (a
lowercase letter). No additional separator characters such as ='_'=, ='-'=, ='$'=, ='@'=, ='#'=, etc. are permitted.

Naming Conventions:

#+NAME: lst:sdml-ex-identifiers
#+CAPTION: SDML Identifier Examples
#+BEGIN_SRC sdml
UpperCamel
lowerCamel
SHOUTY
#+END_SRC

- *Module Name* :: lower Camel Case; i.e. =xsd=, =skos=, =bank=, or =customer=. In general this should be a broad noun.
- *Structure/Entity/Event/Enum Name* :: Upper Camel Case; i.e. =Customer=, =Account=, =Address=, or =Name=. In general
  these are nouns related to, and often narrower than, the module name.
- *Data Type Name* :: Upper Camel Case; i.e. =ShortString=, =AccountNumber=, or =SocialSecurityNumber=. In general these are
  broad nouns, with either a property noun suffix as in =AccountNumber= or a qualifier noun prefix as in =ShortString=. Do
  not create capitalized acronym (SSN) or abbreviation (ID) forms unless these are universally understood within the
  domain.
- *Type Member Name* :: lower Camel Case; i.e. =street=, =accountName=, or =currentValue=. As in data type definitions these are
  broad nouns, with either a property noun suffix as in =accountNumber= or a qualifier noun prefix as in =shortName=. These
  are commonly simply the lower Camel Case version of the corresponding type name.
- *Enum Variant Name* :: Upper Camel Case is the preferred, although SHOUTY CASE is acceptable.

#+NAME: lst:sdml-ex-qualified-identifiers
#+CAPTION: SDML Qualified Identifier Example
#+BEGIN_SRC sdml
module:Member
#+END_SRC

** Module Declaration and Imports

An empty module, specifically a module with an empty /body/ which is the content between the keywords *=is=* and *=end=*. 

#+NAME: lst:sdml-ex-empty-module
#+CAPTION: SDML Empty Module
#+BEGIN_SRC sdml
module example is end
#+END_SRC

This module contains a single import statement bringing in the module named =xsd= making it's members available in the
qualified form =xsd:*=.

#+NAME: lst:sdml-ex-import-module
#+CAPTION: SDML Importing Module
#+BEGIN_SRC sdml
module example is
  import xsd
end
#+END_SRC

#+NAME: lst:sdml-ex-import-member
#+CAPTION: SDML Importing Member
#+BEGIN_SRC sdml
module example is
  import xsd:integer
end
#+END_SRC

#+NAME: lst:sdml-ex-import-list
#+CAPTION: SDML Importing a List
#+BEGIN_SRC sdml
module example is
  import [ dc:title dc:author ]
end
#+END_SRC

#+NAME: lst:sdml-ex-import-from
#+CAPTION: SDML Importing From URL
#+BEGIN_SRC sdml
module example is
  import show from <http://example.org/vocab/show/>
end
#+END_SRC

** Data Types and Values

*** Simple Values

#+NAME: lst:sdml-ex-simple-values
#+CAPTION: SDML Simple Value Examples
#+BEGIN_SRC sdml
"a string"
"a language-tagged string"@en-US
<https://...>  ;; an IRI reference
true false     ;; booleans
123            ;; integer
123.0          ;; decimal
123.0e-10      ;; double
#+END_SRC

IRI references are more permissive in the SDML grammar than the Turtle[fn:3] language. 

*** Value Lists

#+NAME: lst:sdml-ex-value-lists
#+CAPTION: SDML Value List Example
#+BEGIN_SRC sdml
[ "yes" "no" "maybe" ]
#+END_SRC

*** Value Constructors

#+NAME: lst:sdml-ex-type-constructor
#+CAPTION: SDML Type Constructor Example
#+BEGIN_SRC sdml
xsd:unsigned(1)
#+END_SRC

*** Defining Data Types

#+NAME: lst:sdml-ex-datatype
#+CAPTION: SDML Datatype
#+BEGIN_SRC sdml
datatype name <- xsd:string
#+END_SRC

#+NAME: lst:sdml-ex-restricted-datatype
#+CAPTION: SDML Datatype with Restrictions
#+BEGIN_SRC sdml
datatype name <- xsd:string is
  @xsd:minLength = 5
  @xsd:maxLength = 25
end
#+END_SRC

From [[https://www.w3.org/2007/OWL/wiki/Quick_Reference_Guide][OWL 2 Web Ontology Language Quick Reference Guide (Second Edition)]]:

#+NAME: tbl:owl-facets
#+CAPTION: OWL Built-in Datatype Facets
| Facet                                                                  | Value                                      | Applicable Datatypes       | Explanation                                                                                |
|------------------------------------------------------------------------+--------------------------------------------+----------------------------+--------------------------------------------------------------------------------------------|
| =xsd:minInclusive=, =xsd:maxInclusive=, =xsd:minExclusive=, =xsd:maxExclusive= | literal in the corresponding datatype      | Numbers, Time Instants     | Restricts the value-space to greater than (equal to) or lesser than (equal to) a value     |
| =xsd:minLength=, =xsd:maxLength=, =xsd:length=                               | Non-negative integer                       | Strings, Binary Data, IRIs | Restricts the value-space based on the lengths of the literals                             |
| =xsd:pattern=                                                            | =xsd:string= literal as a regular expression | Strings, IRIs              | Restricts the value space to literals that match the regular expression                    |
| =rdf:langRange=                                                          | =xsd:string= literal as a regular expression | =rdf:PlainLiteral=           | Restricts the value space to literals with language tags that match the regular expression |

** Annotations

#+NAME: lst:sdml-ex-annotation-property
#+CAPTION: SDML Annotation Property
#+BEGIN_SRC sdml
@xml:base <https://github.com/johnstonskj/tree-sitter-sdml/blob/main/docs/sdml.org>
#+END_SRC

#+NAME: lst:sdml-ex-annotation-property-list
#+CAPTION: SDML Annotation Property List
#+BEGIN_SRC sdml
@skos:prefLabel [
  "example"@en
  "exemple"@fr
  "例子"@zh-CH
]
#+END_SRC

#+NAME: lst:sdml-ex-annotated-module
#+CAPTION: SDML Annotated Module
#+BEGIN_SRC sdml
module example is

  import xml skos

  @xml:base <https://github.com/johnstonskj/tree-sitter-sdml/blob/main/docs/sdml.org>

  @skos:prefLabel "Example Module"@en

end
#+END_SRC

From [[https://www.w3.org/TR/owl-ref/#AnnotationProperty-def][OWL Web Ontology Language Reference]], Appendix E: Rules of Thumb for OWL DL ontologies:

#+BEGIN_QUOTE
If a property =a= is used where an annotation property is expected then it should either be one of the built in
annotation properties (=owl:versionInfo=, =rdfs:label=, =rdfs:comment=, =rdfs:seeAlso=, and =rdfs:isDefinedBy=) or there
should be a triple:

=a rdf:type owl:AnnotationProperty=
#+END_QUOTE

** Structured Types

#+NAME: lst:sdml-ex-empty-structure
#+CAPTION: SDML Empty Structure
#+BEGIN_SRC sdml
structure Length
#+END_SRC

#+NAME: lst:sdml-ex-annotated-structure
#+CAPTION: SDML Annotated Structure
#+BEGIN_SRC sdml
structure Length is
  @skos:prefLabel "Length"@en
end
#+END_SRC

#+NAME: lst:sdml-ex-structure-members
#+CAPTION: SDML Structure Members
#+BEGIN_SRC sdml
structure Length is
  @skos:prefLabel "Length"@en

  value -> Decimal
  unit -> DistanceUnit
end
#+END_SRC

#+NAME: lst:sdml-ex-structure-groups
#+CAPTION: SDML Structure MembersGroups
#+BEGIN_SRC sdml
structure Account is
  @skos:prefLabel "Customer Account"@en

  group
    @skos:prefLabel "Metadata"
   created -> xsd:dateTime
  end

  group
    @skos:prefLabel "Customer Information"
    ref customer -> {1..1} Customer
  end
end
#+END_SRC

*** Entities

#+NAME: lst:sdml-ex-empty-entity
#+CAPTION: SDML Empty Entity
#+BEGIN_SRC sdml
entity Person
#+END_SRC

#+NAME: lst:sdml-ex-entity-identifying-member
#+CAPTION: SDML Entity with Identifying Member
#+BEGIN_SRC sdml
entity Person is
  identifier id -> PersonId
end
#+END_SRC

#+NAME: lst:sdml-ex-entity-ref-member
#+CAPTION: SDML Entity with Reference Member
#+BEGIN_SRC sdml
entity Person is
  ref contact {0..} -> {0..2} Person is
    @dc:description "Emergency contact person"
  end
end
#+END_SRC

*** Enums

#+NAME: lst:sdml-ex-empty-enum
#+CAPTION: SDML Empty Enum
#+BEGIN_SRC sdml
enum DistanceUnit
#+END_SRC

#+NAME: lst:sdml-ex-enum
#+CAPTION: SDML Enum With Variants
#+BEGIN_SRC sdml
enum DistanceUnit is
  Meter = 1
  Foot = 2
end
#+END_SRC

*** Events

#+NAME: lst:sdml-ex-empty-event
#+CAPTION: SDML Empty Event
#+BEGIN_SRC sdml
event PersonNameChanged source Person
#+END_SRC

#+NAME: lst:sdml-ex-event
#+CAPTION: SDML Event
#+BEGIN_SRC sdml
event PersonNameChanged source Person is
  ;; identifier members will be copied from Person 
  fromValue -> Name
  toValue -> Name
end
#+END_SRC

# ----- Footnotes

[fn:3] [[https://www.w3.org/TR/turtle/#sec-iri-references][RDF 1.1 Turtle]], 6.3 IRI References


* Walk-Through Example

The following section walks through the process of model creation and iterative elaboration to add detail as domain
experts provide more information. In our example we will build a domain model for a vehicle rental company. So, as you
might imagine we can start the model with some pretty obvious entities, but with no detail beyond their names. Listing
[[lst:example-first-pass]] is this first-pass domain model.

#+NAME: lst:example-first-pass
#+CAPTION: First Pass Concepts
#+BEGIN_SRC sdml
module rentals is

  entity Vehicle

  entity Location

  entity Customer

  entity Booking

end
#+END_SRC

The =sdml= tool can be used to generate a concept diagram, a high-level view of only the entities in the model and their
relationships. The following command-line will generate figure [[fig:example-first-pass]] from listing
[[lst:example-first-pass]].

#+BEGIN_EXAMPLE
sdml draw --diagram concepts \
          --output-format svg \
          --output-file ./rentals-concept-1.svg \
          tests/rental-1.sdm
#+END_EXAMPLE

#+NAME: fig:example-first-pass
#+CAPTION: First Pass Concept Diagram
[[./rentals-concept-1.svg]]

Figure [[lst:example-second-pass]] is the second-pass at our model, adding relationships from the ~Booking~ entity to the
~Customer~, ~Location~, and  ~Vehicle~ entities. Adding a body to the ~Booking~ entity, between =is= … =end=, requires the entity
specify an identifier. To allow the addition of ~bookingCode~ without spending time on the details of it's type the
keyword ~unknown~ is used to defer the type until later.

Additionally, the ~vehicle~ relationship specifies a new cardinality overriding the usual =0..= with =0..1=.

#+NAME: lst:example-second-pass
#+CAPTION: Basic Relationships
#+BEGIN_SRC sdml
module rentals is

  entity Vehicle

  entity Location

  entity Customer

  entity Booking is
    identity bookingCode -> unknown

    ref vehicle -> {0..1} Vehicle
    ref from -> Location
    ref customer -> Customer
  end

end
#+END_SRC

Re-running the =sdml= tool on listing [[lst:example-second-pass]] will result in the relationships added, as shown in figure
[[fig:example-second-pass]].

#+NAME: fig:example-second-pass
#+CAPTION: Basic Relationships
[[./rentals-concept-2.svg]]

In the next edit of our rentals model we see some additions:

1. The use of =import= to use the ~VehicleIdentificationNumber~ data type from the ~cids~ (Common Identifiers) model.
1. The new entity ~Class~ to model the rental class of a vehicle.
1. ~Vehicle~ now has an identifier, a relationship to the new ~Class~ entity, and a relationship to ~Location~.
1. ~Booking~ also has a relationship to the new ~Class~ entity.
1. We demonstrate the non-range cardinality notation, ={1}=, which is a shortcut for the range =1..1=.

#+NAME: lst:example-third-pass
#+CAPTION: Some More Detail
#+BEGIN_SRC sdml
module rentals is

  import cids:VehicleIdentificationNumber

  entity Class

  entity Vehicle is
    identity vin -> VehicleIdentificationNumber

    ref rentalClass -> {1} Class
    ref onProperty -> {0..1} Location
  end

  entity Location

  entity Customer

  entity Booking is
    identity bookingCode -> unknown

    ref bookingClass -> {1} Class
    ref vehicle -> {0..1} Vehicle
    ref from -> Location
    ref customer -> {1} Customer
  end

end
#+END_SRC

As usual we generate the concept diagram in figure [[fig:example-third-pass]] from listing [[lst:example-third-pass]].

#+NAME: fig:example-third-pass
#+CAPTION: Some More Detail
[[./rentals-concept-3.svg]]

#+NAME: lst:example-fourth-pass
#+CAPTION: Non-Entity Detail
#+BEGIN_SRC sdml
module rentals is

  import cids:VehicleIdentificationNumber
  import [xsd:date xsd:string]

  entity Class

  entity Vehicle is
    identity vin -> VehicleIdentificationNumber

    ref rentalClass -> {1} Class
  end

  entity Location is
    identity id -> cids:Uuid

    address -> {1} Address
  end

  entity Customer is
    identity id -> cids:Uuid

    contactAddress -> {1} Address
    driverLicense -> {0..1} LicenseInformation
  end

  structure Address

  structure LicenseInformation is
    number -> xsd:string
    state -> xsd:string
    expiration -> xsd:date
  end

  entity Booking is
    identity bookingCode -> unknown

    ref bookingClass -> {1} Class
    ref vehicle -> {0..1} Vehicle
    ref pickup -> {1} Location
    pickupDate -> {1} xsd:date
    ref dropoff -> {1} Location
    dropoffDate -> {1} xsd:date
    ref customer -> {1} Customer
  end

end
#+END_SRC

As usual we generate the concept diagram in figure [[fig:example-fourth-pass]] from listing [[lst:example-fourth-pass]].

#+NAME: fig:example-fourth-pass
#+CAPTION: Non-Entity Detail
[[./rentals-concept-4.svg]]

#+NAME: fig:example-fourth-pass-erd
#+CAPTION: ERD Diagram
[[./rentals-erd-4.svg]]


* Transforms

TBD


* Implementation and Tools

#+NAME: fig:implementation-overview
#+BEGIN_SRC dot :file implementation-overview.png :exports results
digraph G {
    bgcolor="transparent";
    rankdir="TB";
    fontname="Helvetica,Arial,sans-serif";
    node [fontname="Helvetica,Arial,sans-serif"; fontsize=10];
    edge [fontname="Helvetica,Arial,sans-serif"; fontsize=9; fontcolor="dimgrey"; labelfontcolor="blue"; labeldistance=2.0];

    subgraph cluster_0 {
        label = "Core Library";
        grammar [label="Grammar\nDefinition"];
        parser [label="Parser\nDylib"];
        rust [label="Rust\nBindings"];
        npm [label="Node\nBindings"];
        wasm [label="WASM\nBindings"];

        grammar -> parser;
        parser -> rust;
        parser -> npm;
        parser -> wasm;
    }

    treesit [shape=rect; label="Tree-Sitter\nC Library"];
    treesit -> grammar;

    subgraph cluster_1 {
        label = "Emacs Support";
        emode [label="Editing Mode"];
        spell [label="Spell Checker"];
        flycheck [label="Flycheck"];
        emode -> spell;
        emode -> flycheck;

        parser -> emode;
    }

    ets [shape=rect; label="Emacs\nTree-Sitter"];
    ets_hl [shape=rect; label="Tree-Sitter\nHighlighter"];
    ets_indent [shape=rect; label="Tree-Sitter\nIndenter"];
    ets_fold [shape=rect; label="Tree-Sitter\nFolder"];

    treesit -> ets;
    ets -> ets_hl;
    ets -> ets_indent;
    ets -> ets_fold;

    ets_hl -> emode;
    ets_indent -> emode;
    ets_fold -> emode;

    subgraph cluster_2 {
        label = "Command-Line Tool";
        api [label="API"];
        fmt [label="Formatter"];
        linter [label="Linter"];
        diagrams [label="Diagrammer"];

        rust -> api;
        api -> fmt;
        api -> linter;
        api -> diagrams;
    }
}
#+END_SRC
 
#+CAPTION: Implementation Overview
#+RESULTS: fig:implementation-overview
[[file:implementation-overview.png]]


** Core Library

Build.

#+BEGIN_EXAMPLE
git clone https://github.com/johnstonskj/tree-sitter-sdml
#+END_EXAMPLE

#+BEGIN_EXAMPLE
make setup
#+END_EXAMPLE

#+BEGIN_EXAMPLE
make build
#+END_EXAMPLE
 
** Command-Line Tool

** Editor Support

*** Emacs (< 29)

Follow the directions in the /read-me/ file for the Emacs [[https://github.com/johnstonskj/emacs-sdml-mode][tree-sitter]] package.

*** Emacs (>= 29)

TBD

*** Neovim

TBD

*** VSCode

Try here: https://github.com/georgewfraser/vscode-tree-sitter


* Appendix: Surface Syntax to RDF

TBD

** Whitespace

Whitespace present in the surface syntax has *no* effect on the corresponding RDF.

** Comments

Comments present in the surface syntax are *not* translated into the corresponding RDF.;

** Identifiers

Identifiers for modules and type definitions are appended to the base IRI of the module resource, making individual
types within a module directly addressable.

*Example:*

Given a resource retrieved from =https://example.com/v/example/= and containing the following:

#+BEGIN_SRC sdml
module example is
end
#+END_SRC

The module within has the IRI identifier =https://example.com/v/example/example=.

However, if the module overrides the retrieved location using =xml:base=, as follows:

#+BEGIN_SRC sdml
module example is
  import xml:base
  @xml:base = <https://example.org/langs/Example#>
end
#+END_SRC

The module within this resource now has the IRI identifier =https://example.org/langs/Example#example=.

The remainder of this section will use example modules with =xml:base= to make identifier IRIs more easily understood.

** Values

*** Simple Value Literals

| SDML Type     | Underlying Type | Value Space                                                  | Lexical Space  |
|---------------+-----------------+--------------------------------------------------------------+----------------|
| =boolean=       | =xsd:boolean=     | The values =true= and =false=                                    | =true= and =false= |
| =decimal=       | =xsd:decimal=     | A 128-bit representation of a fixed-precision decimal number | [[https://www.w3.org/TR/xmlschema-2/#decimal][XML Schema]]     |
| =double=        | =xsd:double=      | An IEEE double-precision 64-bit floating point type          | [[https://www.w3.org/TR/xmlschema-2/#double][XML Schema]]     |
| =integer=       | =xsd:integer=     | A signed 64-bit integer                                      |                |
| =iri_reference= | =xsd:AnyURI=      | Represents a Uniform Resource Identifier Reference (URI)     | [[https://www.w3.org/TR/xmlschema-2/#anyURI][XML Schema]]     |
| =string=        | =rdfs:langString= |                                                              | [[https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal][RDF]]            |

*** List Literals

*Example:*

Given the following list literal:

#+BEGIN_SRC sdml
@skos:altLabel = [ "yes" "no" "maybe" ]
#+END_SRC

The generated RDF consists of separate statements for each value in the list.

#+BEGIN_SRC ttl
:thing skos:altLabel "yes" .
:thing skos:altLabel "no" .
:thing skos:altLabel "maybe" .
#+END_SRC

For clarity and brevity this is usually written in Turtle as an object list (Turtle [[https://www.w3.org/TR/turtle/#object-lists][2.3 Object Lists]]):

#+BEGIN_SRC ttl
:thing skos:altLabel "yes", "no", "maybe" .
#+END_SRC

Currently there is no mapping from the surface syntax to list values, that is an RDF Collection (Turtle [[https://www.w3.org/TR/turtle/#collections][2.8 Collections]])
which constructs a list using the =rdf:first= and =rdf:rest= predicates. This would result in the following RDF:

#+BEGIN_SRC ttl
:thing skos:altLabel ( "yes", "no", "maybe" ) .
#+END_SRC

*** Value Constructors

** Modules

*Example with Implied Base:*

#+BEGIN_SRC sdml
module example is end
#+END_SRC


#+BEGIN_SRC ttl
@base <https://example.com/v/example/> .
@prefix : <https://example.com/v/example/> .
@prefix sdml: <https://api.amazonadvertising.com/domain-model> .

:example rdf:type sdml:Module .
#+END_SRC

*Example with Explicit Base:*

#+BEGIN_SRC sdml
module example is
  import xml:base
  @xml:base = <https://example.org/langs/Example#>
end
#+END_SRC


#+BEGIN_SRC ttl
@base <https://example.org/langs/Example#> .
@prefix : <https://example.org/langs/Example#> .
@prefix sdml: <https://api.amazonadvertising.com/domain-model> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .

:example rdf:type sdml:Module .
#+END_SRC

** Imports

*Example with Implicit Location:*

#+BEGIN_SRC sdml
module example is
  import xml
end
#+END_SRC


*Example with Explicit Location:*

#+BEGIN_SRC sdml
module example is
  import xml from <file:///usr/local/share/schema/xml.ttl>
end
#+END_SRC

** Annotations

** Data Type Definition

*Example:*

#+BEGIN_SRC sdml
datatype name <- xsd:string
#+END_SRC

#+BEGIN_SRC ttl
:name rdf:type rdfs:Datatype ;
    owl:onDatatype xsd:string .
#+END_SRC

*Example with Restrictions:*

#+BEGIN_SRC sdml
datatype name <- xsd:string is
  @xsd:minLength = 5
  @xsd:maxLength = 25
end
#+END_SRC

#+BEGIN_SRC ttl
:name rdf:type rdfs:Datatype ;
    owl:onDatatype xsd:string ;
    owl:withRestrictions (
        [ xsd:minLength "5"^^xsd:nonNegativeInteger ]
        [ xsd:maxLength "25"^^xsd:nonNegativeInteger ]
    ) .
#+END_SRC

** Entity Definition

*Example Empty Entity:*

#+BEGIN_SRC sdml
entity Person
#+END_SRC

#+BEGIN_SRC ttl
:Person rdf:type sdml:Entity .
#+END_SRC

*Example Entity with Identity:*

#+BEGIN_SRC sdml
entity Person is
  identifier id -> PersonId
end
#+END_SRC

#+BEGIN_SRC ttl
:Person rdf:type sdml:Entity ;
    :hasIdentifyingMember [
        rdfs:label "id" ;
        :targetClassifier :Person ;
    ] .
#+END_SRC

*Example Entity with By-Value Member:*

TBD

*Example Entity with By-Reference Member:*

#+BEGIN_SRC sdml
entity Person is
  ref contact {0..} -> {0..2} Person is
    @dc:description "Emergency contact person"
  end
end
#+END_SRC

#+BEGIN_SRC ttl
:Person rdf:type sdml:Entity ;
    :hasReferenceMember [
        rdfs:label "contact" ;
        :targetClassifier :Person ;
        :sourceCardinality [
            owl:minCardinality 0 ;
        ] ;
        :targetCardinality [
            owl:minCardinality 0 ;
            owl:maxCardinality 2 ;
        ]
        dc::description "Emergency contact person"
    ] .
#+END_SRC

*Example Entity with Group:*

TBD

** Enumeration Definition

*Example Empty Enumeration:*

#+BEGIN_SRC sdml
enum DistanceUnit
#+END_SRC

#+BEGIN_SRC ttl
:DistanceUnit rdf:type sdml:Enumeration .
#+END_SRC

*Example Enumeration with Variants:*

#+BEGIN_SRC sdml
enum DistanceUnit is
  Meter = 1
  Foot = 2
end
#+END_SRC

#+BEGIN_SRC ttl
:DistanceUnit rdf:type sdml:Enumeration
    :hasVariant [
        rdfs:label "Meter" ;
        :hasValue 1 
    ] ,
    [
        rdfs:label "Foot" ;
        :hasValue 2
    ] .
#+END_SRC

** Event Definition

*Example Empty Event:*

#+BEGIN_SRC sdml
event PersonNameChanged source Person
#+END_SRC

#+BEGIN_SRC ttl
:PersonNameChanged rdf:type sdml:Event ;
    sdml:eventSource :Person .
#+END_SRC

*Example Event with Members:*

#+BEGIN_SRC sdml
event PersonNameChanged source Person is
  ;; identifier members will be copied from Person 
  fromValue -> Name
  toValue -> Name
end
#+END_SRC

#+BEGIN_SRC ttl
:PersonNameChanged rdf:type sdml:Event ;
    sdml:eventSource :Person ;
    :hasMember [
        rdfs:Label "personId" ;
        :targetClassifier :Person
    ] ,
    [
        rdfs:Label "fromValue" ;
        :targetClassifier :Name
    ] ,
    [
        rdfs:Label "toValue" ;
        :targetClassifier :Name
    ] .
#+END_SRC

** Structure Definition

*Example Empty Structure:*

#+BEGIN_SRC sdml
structure Length
#+END_SRC

#+BEGIN_SRC ttl
:Length rdf:type sdml:Structure ;
    rdfs:isDefinedBy :module .
#+END_SRC

*Example Structure with Annotation:*

#+BEGIN_SRC sdml
structure Length is
  @skos:prefLabel "Length"@en
end
#+END_SRC

#+BEGIN_SRC ttl
:Length rdf:type sdml:Structure ;
    skos:prefLabel "Length"@en .
#+END_SRC

*Example Structure with Members:*

#+BEGIN_SRC sdml
structure Length is
  @skos:prefLabel "Length"@en

  value -> Decimal
  unit -> DistanceUnit
end
#+END_SRC

#+BEGIN_SRC ttl
:Length rdf:type sdml:Structure ;
    skos:prefLabel "Length"@en .
    :hasMember [
        rdfs:label "value" ;
        :targetClassifier :Decimal ;
    ] ,
    [
        rdfs:label "unit" ;
        :targetClassifier :DistanceUnit ;
    ] .
#+END_SRC

*Example Structure with Groups:*

#+BEGIN_SRC sdml
structure Account is
  @skos:prefLabel "Customer Account"@en

  group
    @skos:prefLabel "Metadata"
   created -> xsd:dateTime
  end

  group
    @skos:prefLabel "Customer Information"
    ref customer -> {1..1} Customer
  end
end
#+END_SRC


* Appendix: Known URI Prefixes

The following prefixes may be used in import statements without the need to reference their location directly. Either
the namespace URI will be used to retrieve the corresponding resource or a local copy will be used.

| Prefix    | URI                                           |
|-----------+-----------------------------------------------|
| =dbpedia=   | <http://dbpedia.org/resource/>                |
| =dbpprop=   | <http://dbpedia.org/property/>                |
| =dc=        | <http://purl.org/dc/elements/1.1/>            |
| =dcterms=   | <http://purl.org/dc/terms/>                   |
| =dctype=    | <http://purl.org/dc/dcmitype/>                |
| =dcam=      | <http://purl.org/dc/dcam/>                    |
| =foaf=      | <http://xmlns.com/foaf/0.1/>                  |
| =geo=       | <http://www.w3.org/2003/01/geo/wgs84_pos#>    |
| =ldp=       | <http://www.w3.org/ns/ldp#>                   |
| =math=      | <http://www.w3.org/2000/10/swap/math#>        |
| =owl=       | <http://www.w3.org/2002/07/owl#>              |
| =rdf=       | <http://www.w3.org/1999/02/22-rdf-syntax-ns#> |
| =rdfs=      | <http://www.w3.org/2000/01/rdf-schema#>       |
| =sioc=      | <http://rdfs.org/sioc/ns#>                    |
| =skos=      | <http://www.w3.org/2004/02/skos/core#>        |
| =vcard=     | <http://www.w3.org/2001/vcard-rdf/3.0#>       |
| =vcard2006= | <http://www.w3.org/2006/vcard/ns#>            |
| =void=      | <http://rdfs.org/ns/void#>                    |
| =xml=       | <http://www.w3.org/XML/1998/namespace>        |
| =xsd=       | <http://www.w3.org/2001/XMLSchema#>           |


* Appendix: Tables of Other Content

#+TOC: figures

#+TOC: tables

#+TOC: listings
