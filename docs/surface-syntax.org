#+LANGUAGE: en
#+STARTUP: overview hidestars inlineimages entitiespretty

* Surface Syntax

This section describes the SDML surface syntax, a syntax intended to look and feel like a programming language but with
extensibility provided by it's underlying RDF and OWL foundation. The goal of the following syntax is to allow for rapid
capture of domain information but allowing elaboration of details over time. To this end we have made language features
optional wherever possible such that the minimum information neccessary is required to build a valid model. This
document will use the terms /valid/ to denote a model that has no syntactic errors and /complete/ to denote a valid model
that has no short-form, or /incomplete/, model elements.

For the complete grammar, and notes on BNF notation, see Appendix [[app:syntax]].

** Whitespace and Comments

This grammar chooses to use the JavaScript regular expression character class =\s= which includes the following values,
including all Unicode whitespace.

#+NAME: lst:grammar-whitespace
#+BEGIN_SRC ebnf
Whitespace      =
    "\f" | "\n" | "\r" | "\t" | "\v"
    | "\u{0020}" | "\u{00a0}" | "\u{1680}" | "\u{2000}".."\u{200a}"
    | "\u{2028}" | "\u{2029}" | "\u{202f}" | "\u{205f}" | "\u{3000}"
    | "\u{feff}"
#+END_SRC

Comments follow Lisp-like forms, starting with a semi-colon character and continuing to the end of line.

#+NAME: lst:grammar-line-comment
#+BEGIN_SRC ebnf
LineComment     = ";", ( -( "\r" | "\n" ) )*
#+END_SRC

#+NAME: lst:sdml-ex-comments
#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
; <- comments start here, end here ->
#+END_SRC

Lisp conventions for single, double, and triple comment characters are useful but in no way enforced.

#+NAME: lst:sdml-ex-comment-conventions
#+CAPTION: Comments
#+BEGIN_SRC sdml :exports code :noeval
;;; File-level comment
;; Comment at-point
; Comments in right margin
#+END_SRC

** Identifiers

An identifier is a string of characters corresponding to the [[https://unicode.org/reports/tr44/#GC_Values_Table][Unicode General Category]] *Lu* (an uppercase letter) or *Ll* (a
lowercase letter) or the Unicode Low Line (underscore, "_", =U+005F=) character. Specifically an identifer *must* start with
and *must* end with a letter such that the low line character may only appear /within/ the identifier. The following is a
brief BNF description of the identifier syntax.

#+NAME: lst:grammar-identifier
#+BEGIN_SRC ebnf
IdentifierWord  = ( UC_LETTER_UPPER | UC_LETTER_LOWER )+
Identifier      = IdentifierWord, ( "_", IdentifierWord )*
#+END_SRC
    
Naming Conventions:

- *Module Name* :: lower Camel Case; i.e. =xsd=, =skos=, =bank=, or =customer=. In general this should be a broad noun.
- *Structure/Entity/Event/Enum Name* :: Upper Camel Case; i.e. =Customer=, =Account=, =Address=, or =Name=. In general
  these are nouns related to, and often narrower than, the module name.
- *Data Type Name* :: Upper Camel Case; i.e. =ShortString=, =AccountNumber=, or =SocialSecurityNumber=. In general these are
  broad nouns, with either a property noun suffix as in =AccountNumber= or a qualifier noun prefix as in =ShortString=. Do
  not create capitalized acronym (SSN) or abbreviation (ID) forms unless these are universally understood within the
  domain.
- *Type Member Name* :: lower Camel Case; i.e. =street=, =accountName=, or =currentValue=. As in data type definitions these are
  broad nouns, with either a property noun suffix as in =accountNumber= or a qualifier noun prefix as in =shortName=. These
  are commonly simply the lower Camel Case version of the corresponding type name.
- *Enum and Union Variant Name* :: Upper Camel Case is the preferred, although SHOUTY CASE is acceptable.

*** Qualified Identifier

A qualified identifier comprises a module identifier followed by the Colon (":", =U+003A=) character and the identifier of a
member within that module.

#+NAME: lst:grammar-qualified-identifier
#+BEGIN_SRC ebnf
QualifiedIdentifier = Identifier, ":", Identifier
#+END_SRC

A type reference may be to a locally defined type by an identifier, or an imported type by a qualified identifier.

#+NAME: lst:grammar-identifier-reference
#+BEGIN_SRC ebnf
IdentifierReference = QualifiedIdentifier | Identifier
#+END_SRC

** <<sec:modules-and-imports>> Module Declaration and Imports

A module is the container for a set of type definitions and typically models a /Domain/ or /Sub-domain/. A single resource
(in the web sense of some /thing/ identified by an IRI) may contain only a single module. Therefore, the smallest valid
resource is one with an empty model.

#+NAME: lst:grammar-module
#+BEGIN_SRC ebnf
ModuleBody      = "is", ImportStatement*, Annotation*, TypeDef*, "end"
Module          = "module", Identifier, ModuleBody
#+END_SRC

An empty module (listing [[lst:sdml-ex-empty-module]]), specifically a module with an empty /body/ which is the content
between the keywords *=is=* and *=end=*.

#+NAME: lst:sdml-ex-empty-module
#+CAPTION: Empty Module
#+BEGIN_SRC sdml :exports code :noeval
module example is end
#+END_SRC

To import types from other modules you add one or more import statements to the module body. Each statement may
reference one or more module names or the qualified name of a type within a module.

#+NAME: lst:grammar-import-statement
#+BEGIN_SRC ebnf
MemberImport    = QualifiedIdentifier
ModuleImport    = Identifer
Import          = MemberImport | ModuleImport
ImportStatement = "import", ( Import | "[", Import+, "]" )
#+END_SRC


The module in listing [[lst:sdml-ex-import-module]] contains a single import statement /referencing/ the module named =xsd=
making it's members /visible/ in the qualified form =xsd:*=.

#+NAME: lst:sdml-ex-import-module
#+CAPTION: Importing Module
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xsd
end
#+END_SRC

The module in listing [[lst:sdml-ex-import-member]] contains a single import statement /referencing/ the member named =integer= from
the module =xsd= making it visible.

#+NAME: lst:sdml-ex-import-member
#+CAPTION: Importing Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xsd:integer
end
#+END_SRC

To reduce the number of import statements a list of identifiers, both module and member, may be /referenced/ as a list.
Listing [[lst:sdml-ex-import-list]] makes the members =author= and =title= from the module =dc= visible. Lists in SDML start
with the Left Square Bracket ("[", =U+005B=) character and end with the Right Square Bracket ("]", =U+005D=) character with
no separator character between members of the list.

#+NAME: lst:sdml-ex-import-list
#+CAPTION: Importing a List
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import [ dc:title dc:author ]
end
#+END_SRC

** Data Types and Values

A data /value/ is either a simple value, a value constructor expression, an identifier reference or a list of values.

#+NAME: lst:grammar-value
#+BEGIN_SRC ebnf
Value           =
    SimpleValue
    | ValueConstructor
    | IdentifierReference
    | ListOfValues
#+END_SRC

The inclusion if an identifier reference allows for annotations whose value is another model element.

*** Simple Values

The core data types supported by SDML are Boolean, Integer, Decimal, Double, String, (Language-Tagged String), and IRI
References. Values corresponding to these types are termed /simple values/.

#+NAME: lst:grammar-simple-value
#+BEGIN_SRC ebnf
SimpleValue     =
    String
    | Double
    | Decimal
    | Integer
    | Boolean
    | IriReference
#+END_SRC

A *Boolean* value in SDML is either the keyword ~true~ or ~false~.

#+NAME: lst:grammar-boolean
#+BEGIN_SRC ebnf
Boolean         = "true" | "false"
#+END_SRC

An *Integer* value in SDML is a string of ASCII decimal digits, without leading zeros; zero, =0=, is a valid value however
=00= and =01= are not. The Integer type corresponds to a 64-bit signed integer number.

#+NAME: lst:grammar-integer
#+BEGIN_SRC ebnf
NumericSign     = "+" | "-"
Zero            = "0"
NonZero         = "1".."9"
Unsigned        = Zero | NonZero, ( ASCII_DIGIT )*
Integer         = NumericSign?, Unsigned
#+END_SRC

A *Decimal* value in SDML is an integer-like value, followed by the Full Stop (".", =U+002E=) character and another
integer-like value. The Decimal type corresponds to a 128-bit representation of a fixed-precision decimal number.

#+NAME: lst:grammar-decimal
#+BEGIN_SRC ebnf
Decimal         = Integer, ".", ( ASCII_DIGIT )+
#+END_SRC

A *Double* value in SDML is a decimal-like value followed by a lower or upper case letter E (Latin Small Letter E, "e",
=U+0065= or Latin Capital Letter E, "E", =U+0045=), a sign character (Hyphen Minus, "-", =U+002D= or Plus Sign, "+", =U+002B=)
and an integer-like value. The Double type is a 64-bit floating point number (specifically, the "binary64" type defined
in IEEE 754-2008).

#+NAME: lst:grammar-double
#+BEGIN_SRC ebnf
ExponentChar    = "e" | "E"
Double          = Decimal, ExponentChar, NumericSign?, Integer
#+END_SRC

A *String* value in SDML is a sequence of Unicode characters starting and ending with a Quotation Mark ('"', =U+0022=) character. While
standard escape sequences allow for embedding non-printing characters. The form =\u{XXXX}=, where =X= is a single hex digit,
allows for the inclusion of any Unicode characters by their code point. Note that this form requires a minimum of 2 and
a maximum of 6 such digits. In addition,the following single-character escape characters are supported.

#+NAME: lst:grammar-string
#+BEGIN_SRC ebnf
HexPair         = ASCII_HEX_DIGIT, ASCII_HEX_DIGIT
CharacterEscape = "\\", ( "\"" | "\\" | "\/" | "a" | "b"
                          "e" | "f" | "n" | "r" | "t" | "v" )
UnicodeEscape   = "\\u{", HexPair, ( HexPair ( HexPair )? )?, "}"
NotAllowed      = "\"" | "\\" | "\u{00}".."\u{08}" | "\u{0B}".."\u{1F}" | "\u{7F}"
QuotedString    = "\"", ( -NotAllowed | CharacterEscape | UnicodeEscape )*, "\""

LanguageTag     =
    "@", ASCII_LETTER_LOWER, ASCII_LETTER_LOWER, ASCII_LETTER_LOWER?
        ( "-", ASCII_LETTER_UPPER, ASCII_LETTER_UPPER, ASCII_LETTER_UPPER )?
        ( "-", ASCII_LETTER_UPPER, ASCII_LETTER_LOWER,
               ASCII_LETTER_LOWER, ASCII_LETTER_LOWER )?
        ( "-", ( ( ASCII_LETTER_UPPER, ASCII_LETTER_UPPER )
               | ( ASCII_DIGIT, ASCII_DIGIT, ASCII_DIGIT ) ) )
String          = QuotedString, LanguageTag?
#+END_SRC

Note also that strings allow literal newlines and do not /require/ they be present in escaped form. This means that a
string literal supports multiline forms.

#+NAME: tbl:string-escape-characters
#+CAPTION: String Escape Characters
| Escape Character | Character Name (Common Name)          | Unicode Equivalent |
|------------------+---------------------------------------+--------------------|
| =\\=               | Reverse Solidus (Backslash)           | =\u{005C}=           |
| =\/=               | Solidus (Forward Slash)               | =\u{002F}=           |
| =\"=               | Quotation Mark                        | =\u{0022}=           |
| =\a=               | Bell                                  | =\u{0007}=           |
| =\b=               | Backspace                             | =\u{0008}=           |
| =\e=               | Escape                                | =\u{001B}=           |
| =\f=               | Form Feed (Page Break)                | =\u{000C}=           |
| =\n=               | Line Feed (New Line)                  | =\u{000A}=           |
| =\r=               | Carriage Return                       | =\u{000D}=           |
| =\t=               | Character Tabulation (Horizontal Tab) | =\u{0009}=           |
| =\v=               | Line Tabulation (Vertical Tab)        | =\u{000B}=           |

A *Language-Tagged String* value in SDML is a String as above but immediately followed by a Commercial At ("@", =U+0040=)
character and an unquoted string of characters that conform to a language identifier. Note that both components of such
a string contribute to equality tests, so that ="abc"@en= is not equal to ="abc"@fr=.

An *IRI Reference value* in SDML is a value IRI value, either absolute or relative, between a Less-Than Sign ("<", =U+003C=)
character and a Greater-Than Sign (">", =U+003E=) character. IRI references are more permissive in the SDML grammar than
the Turtle[fn:3] language.

#+NAME: lst:grammar-iri-reference
#+BEGIN_SRC ebnf
IriReference    =
    "<",
    (
    - ("<" | ">" | "\"" | "{" | "}" | "|" | "^" | "`" | "\\" | "\u{00}".."\u{20}")
    | UnicodeEscape
    )*,
    ">"
#+END_SRC

See section [[sec:mapping-values]] for a more detailed description of values, literals, and data types.

*** Value Constructors

While the value =101= is defined to be an Integer literal, in the presence of sub-types how do you specify the type of a
literal? To accomplish this a /value constructor/ allows for specifying the precise type, or casting a value to a specific
type.

The syntax appears as a function call with a type reference followed by a valid /simple value/ surrounded by the Left
Parenthesis ("(", =U+0028=) and Right Parenthesis (")", =U+0029=) characters. The literal value MUST be valid for the
referenced type, or one of it's super-types.

#+NAME: lst:grammar-value-constructor
#+BEGIN_SRC ebnf
ValueConstructor    = IdentifierReference, "(", SimpleValue, ")"
#+END_SRC

Here we assert that the value =1= is an unsigned rather than the default signed integer.

#+NAME: lst:sdml-ex-type-constructor
#+CAPTION: Value Constructor Example
#+BEGIN_SRC sdml :exports code :noeval
xsd:unsigned(1)
#+END_SRC

*** Value Lists

As stated in section [[sec:modules-and-imports]], lists in SDML start with the Left Square Bracket ("[", =U+005B=)
character and end with the Right Square Bracket ("]", =U+005D=) character with no separator character between members of
the list. Value lists are, as one might expect, lists of values and specifically of simple values. Value lists are also
heterogeneous and may contain elements of different types.

#+NAME: lst:grammar-list-of-values
#+BEGIN_SRC js :noeval
ListOfValues    =
    "[", ( SimpleValue | ValueConstructor | IdentifierReference )+, "]"
#+END_SRC

#+NAME: lst:sdml-ex-value-lists
#+CAPTION: Value List Example
#+BEGIN_SRC sdml :exports code :noeval
[ "yes" "no" "maybe" ]
#+END_SRC

*** Defining Data Types

A datatype definition introduces a new simple data type by /restriction/ of some existing base type.

#+NAME: lst:grammar-data-type-def
#+BEGIN_SRC ebnf
DataTypeDef     =
    "datatype", Identifier, "<-", IdentifierReference, AnnotationOnlyBody?
#+END_SRC

Listing [[lst:sdml-ex-datatype]] shows the /type restriction/ operator, =<-=, defining a new type named ~name~ as a restriction on
the existing XML Schema data type ~xsd:string~.

#+NAME: lst:sdml-ex-datatype
#+CAPTION: New Datatype
#+BEGIN_SRC sdml :exports code :noeval
datatype Name <- xsd:string
#+END_SRC

While such a type is useful for conveying semantic meaning with types it doesn't provide any actual restriction on the
value space of the type. This is accomplished by using a subset of the /facets/ described in XML Schema part 2 to specify
constraints on the new type. For example, in listing [[lst:sdml-ex-restricted-datatype]] we now see that the Name type
is a string whose length is between 5 and 25 characters only.

#+NAME: lst:sdml-ex-restricted-datatype
#+CAPTION: New Datatype with Restrictions
#+BEGIN_SRC sdml :exports code :noeval
datatype Name <- xsd:string is
  @xsd:minLength = 5
  @xsd:maxLength = 25
end
#+END_SRC

From [[https://www.w3.org/2007/OWL/wiki/Quick_Reference_Guide][OWL 2 Web Ontology Language Quick Reference Guide (Second Edition)]]:

#+NAME: tbl:owl-facets
#+CAPTION: OWL Built-in Datatype Facets
| Facet                                                                  | Value                                      | Applicable Datatypes       | Explanation                                                                                |
|------------------------------------------------------------------------+--------------------------------------------+----------------------------+--------------------------------------------------------------------------------------------|
| =xsd:minInclusive=, =xsd:maxInclusive=, =xsd:minExclusive=, =xsd:maxExclusive= | literal in the corresponding datatype      | Numbers, Time Instants     | Restricts the value-space to greater than (equal to) or lesser than (equal to) a value     |
| =xsd:minLength=, =xsd:maxLength=, =xsd:length=                               | Non-negative integer                       | Strings, Binary Data, IRIs | Restricts the value-space based on the lengths of the literals                             |
| =xsd:pattern=                                                            | =xsd:string= literal as a regular expression | Strings, IRIs              | Restricts the value space to literals that match the regular expression                    |
| =rdf:langRange=                                                          | =xsd:string= literal as a regular expression | =rdf:PlainLiteral=           | Restricts the value space to literals with language tags that match the regular expression |

** Annotations

Annotations are an extension mechanism that interacts directly with the underlying RDF representation of the subject
model element. While these may look like Java /annotations/, Python /decorators/, or Rust /attributes/ it is more powerful in
that it can express arbitrary statements about the model element. An SDML annotation starts with the symbol "@" and then
has an identifier that resolves to an OWL annotation property, and a value for the corresponding property range.

#+NAME: lst:grammar-annotation
#+BEGIN_SRC ebnf
Annotation      = "@", IdentiferReference, "=", Value
#+END_SRC

The following example demonstrates an annotation attached to a module.

#+NAME: lst:sdml-ex-annotation-property
#+CAPTION: Annotation Property
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import xml

  @xml:base = <https://github.com/johnstonskj/tree-sitter-sdml/blob/main/docs/sdml.org>
end
#+END_SRC

#+NAME: lst:sdml-ex-annotation-property-list
#+CAPTION: Annotation Property List
#+BEGIN_SRC sdml :exports code :noeval
module example is
  import skos

  @skos:prefLabel = [
    "example"@en
    "exemple"@fr
    "例子"@zh-CH
  ]
end
#+END_SRC

#+NAME: lst:sdml-ex-annotated-module
#+CAPTION: Annotated Module
#+BEGIN_SRC sdml :exports code :noeval
module example is

  import [ xml skos ]

  @xml:base = <https://github.com/johnstonskj/tree-sitter-sdml/blob/main/docs/sdml.org>

  @skos:prefLabel = "Example Module"@en

end
#+END_SRC

From [[https://www.w3.org/TR/owl-ref/#AnnotationProperty-def][OWL Web Ontology Language Reference]], Appendix E: Rules of Thumb for OWL DL ontologies:

#+BEGIN_QUOTE
If a property =a= is used where an annotation property is expected then it should either be one of the built in
annotation properties (=owl:versionInfo=, =rdfs:label=, =rdfs:comment=, =rdfs:seeAlso=, and =rdfs:isDefinedBy=) or there
should be a triple:

=a rdf:type owl:AnnotationProperty=
#+END_QUOTE

** Structured Types

Structured types fall into two primary categories, /Product/ types and /Sum/ types. Product types have named and typed
/Members/ and in SDML these are structures, entities and events. Sum types on the other hand have /Variants/ and in SDML
these are enumerations and disjoint unions.

Along with the previously described datatype these comprise the set of type definitions available in SDML; this is
represented in listing [[lst:grammar-type-def]].

#+NAME: lst:grammar-type-def
#+BEGIN_SRC ebnf
TypeDef         =
    DataTypeDef
    | EntityDef
    | EnumDef
    | EventDef
    | StructureDef
    | UnionDef
#+END_SRC

*** Members

Structured type members fall into the following categories.

- Identity :: A particular kind of member only available on entities, and required by them, to name the identifier for
  that entity type.
- By-Value :: A reference to a value type, i.e. Enumeration, Event, or Structure. Such a member may indicate the
  cardinality of the target.
- By-Reference :: A reference to an Entity type. Such a member may indicate the cardinality of both the source and the
  target.
- Variant :: A member within an enumeration that specifies a numeric value for each member rather than a type.
- *Type Variant* :: A type reference that is a unique variant of a disjoint union.

#+NAME: lst:grammar-members
#+BEGIN_SRC ebnf
IdentityMember      =
    "identity", identifier, TypeExpression, AnnotationOnlyBody?

MemberByValue       =
    identifier, TypeExpressionTo, AnnotationOnlyBody?

MemberByReference   =
    "ref", Identifier, TypeExpressionFromTo,AnnotationOnlyBody?
#+END_SRC

For identity, by-value, and by-reference members the general syntax uses the /type reference/ operator, /name/ ~->~ /type/, with
additional keywords and cardinality included as follows.

#+NAME: tbl:member-summary
#+CAPTION: Summary of Member Formats
| Kind         | Keyword  | From-Cardinality | To-Cardinality | Target Types                     |
|--------------+----------+------------------+----------------+----------------------------------|
| Identity     | ~identity~ | No               | No             | Enumeration, Event, or Structure |
| By-Value     |          | No               | Yes            | Enumeration, Event, or Structure |
| By-Reference | ~ref~      | Yes              | Yes            | Entity                           |

Additionally, to allow for the capture of member names before the elaboration of all types the language allows for the
target type to be replaced with the keyword ~unknown~. This marks the member, and by extension it's owning type, as
/incomplete/.

#+NAME: lst:grammar-type-expressions
#+BEGIN_SRC ebnf
TypeExpression          = "->" TypeReference
TypeExpressionTo        = "->" Cardinality? TypeReference
TypeExpressionFromto    = Cardinality? TypeExpressionTo
TypeReference           = IdentifierReference | UnknownType
UnknownType             = "unknown"
#+END_SRC

The cardinality of a member is specified as a range operation with a minimum and maximum number of occurrences
specified.

- The form ~{1..3}~ specifies a cardinality of 1 to 3 inclusive, or $[1,3]$ in interval notation.
- The form ~{1..}~ specifies a minimum of 1 occurrences an unbounded maximum, or $[1,\infty]$ in interval notation.
- The form ~{1}~ specifies that 1 is both the minimum and maximum value, or $[1,1]$ in interval notation, commonly termed
  a /degenerate/ interval.

#+NAME: lst:grammar-cardinality
#+BEGIN_SRC ebnf
CardinalityExpression   = "{", Unsigned, CardinalityRange?, "}"
CardinalityRange        = "..", Unsigned?
#+END_SRC

*** Structures

A structure is a product type that is composed of named and typed members. A structure is therefore akin to a record
type, a table in data modeling, or a class in object modeling.

#+NAME: lst:grammar-structure-def
#+BEGIN_SRC ebnf
StructureDef    = "structure", Identifier, StructureBody?
StructureBody   = "is", Annotation*, ( MemberByValue | StructureGroup )*, "end"
StructureGroup  = "group", Annotation*, MemberByValue*, "end"
#+END_SRC

As only the keyword ~structure~ and the identifier are required, the listing [[lst:sdml-ex-empty-structure]] is therefore a
valid model.

#+NAME: lst:sdml-ex-empty-structure
#+CAPTION: Empty Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length
end
#+END_SRC

The structure ~Length~ in listing [[lst:sdml-ex-empty-structure]] is /valid/ but considered incomplete. Adding a body to the
structure, between ~is~ and ~end~, makes it complete even if it has no actual members. In listing
[[lst:sdml-ex-annotated-structure]] the structure Length is now complete.

#+NAME: lst:sdml-ex-annotated-structure
#+CAPTION: Annotated Structure
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en
  end
end
#+END_SRC

Listing [[lst:sdml-ex-structure-members]] adds the members ~value~ and ~unit~ and their corresponding types.

#+NAME: lst:sdml-ex-structure-members
#+CAPTION: Structure Members
#+BEGIN_SRC sdml :exports code :noeval
module example is
  structure Length is
    @skos:prefLabel = "Length"@en

    value -> Decimal
    unit -> DistanceUnit
  end
end
#+END_SRC

In listing [[lst:sdml-ex-structure-groups]] we see a more complex structure with both members and groups.

#+NAME: lst:sdml-ex-structure-groups
#+CAPTION: Structure Members and Groups
#+BEGIN_SRC sdml :exports code :noeval
module example is

  structure Account is
    @skos:prefLabel = "Customer Account"@en

    group
      @skos:prefLabel = "Metadata"
      created -> xsd:dateTime
      lastModified -> xsd:dateTime
    end

    group
      @skos:prefLabel = "Customer Information"
      ref customer -> {1..1} Customer
    end
  end

end
#+END_SRC

# ----- Footnotes

[fn:3] [[https://www.w3.org/TR/turtle/#sec-iri-references][RDF 1.1 Turtle]], 6.3 IRI References

*** Entities

#+NAME: lst:grammar-entity-def
#+BEGIN_SRC ebnf
EntityGroup     = "group", Annotation*, ( MemberByValue | MemberByReference )*
EntityBody      =
    "is",
    Annotation*,
    IdentityMember,
    ( MemberByValue | MemberByReference | EntityGroup )*,
    "end"
Entity          = "entity", Identifier, EntityBody?
#+END_SRC

#+NAME: lst:sdml-ex-empty-entity
#+CAPTION: Empty Entity
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person
end
#+END_SRC

The entity ~Person~ is /valid/ but /incomplete/.

#+NAME: lst:sdml-ex-entity-identifying-member
#+CAPTION: Entity with Identifying Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    identity id -> PersonId
  end
end
#+END_SRC

#+NAME: lst:sdml-ex-entity-ref-member
#+CAPTION: Entity with Reference Member
#+BEGIN_SRC sdml :exports code :noeval
module example is
  entity Person is
    ref contact {0..} -> {0..2} Person is
      @dc:description = "Emergency contact person"
    end
  end
end
#+END_SRC

*** Entity Events

#+NAME: lst:grammar-event-def
#+BEGIN_SRC ebnf
EventDef        =
    "event", Identifier,
    "source", IdentifierReference,
    StructureBody?
#+END_SRC

#+NAME: lst:sdml-ex-empty-event
#+CAPTION: Empty Event
#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person
end
#+END_SRC

The event ~PersonNameChanged~ is valid but incomplete.

#+NAME: lst:sdml-ex-event
#+CAPTION: Event
#+BEGIN_SRC sdml :exports code :noeval
module example is
  event PersonNameChanged source Person is
    ;; identifier members will be copied from Person 
    fromValue -> Name
    toValue -> Name
  end
end
#+END_SRC

*** Enumerations

#+NAME: lst:grammar-enum-def
#+BEGIN_SRC ebnf
EnumBody        = "is", Annotation*, EnumVariant+, "end"
EnumDef         = "enum", Identifier, EnumBody?
#+END_SRC

#+NAME: lst:sdml-ex-empty-enum
#+CAPTION: Empty Enum
#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit
end
#+END_SRC

The enumeration ~DistanceUnit~ is valid but incomplete.

#+NAME: lst:grammar-enum-variant
#+BEGIN_SRC ebnf
EnumVariant     = Identifier, "=", Unsigned, AnnotationOnlyBody?
#+END_SRC

#+NAME: lst:sdml-ex-enum
#+CAPTION: Enum With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is
  enum DistanceUnit of
    Meter = 1
    Foot = 2
  end
end
#+END_SRC

*** Disjoint Unions

A disjoint, or discriminated, union is a mechanism to allow for a selection of disjoint types to be treated as a single
type. As such the /elements/ of the union are simply type names and do not allow annotations. Note also that the keyword
=of= and not =is= starts a union body.

#+NAME: lst:grammar-union-def
#+BEGIN_SRC ebnf
UnionDef        = "union", Identifier, UnionBody?
UnionBody       = "of", Annotation*, TypeVariant*, "end"
TypeVariant     = IdentifierReference
#+END_SRC

#+NAME: lst:sdml-ex-empty-union
#+CAPTION: Empty Union
#+BEGIN_SRC sdml :exports code :noeval
module example of
  union VehicleClass
end
#+END_SRC

The union ~VehicleClass~ is valid but incomplete.

#+NAME: lst:sdml-ex-union
#+CAPTION: Union With Variants
#+BEGIN_SRC sdml :exports code :noeval
module example is
  union VehicleClass of
    Car
    Van
    Truck
  end
end
#+END_SRC

